\part{Praktische Umsetzung} \label{sec:praxis} 
% (mein Anteil)  verweis auf technische grundlagen.

\chapter{Konzeption}	
%		Idee, Anforderungen -> plattformunabhägig
%		Funktionalitätsbeschreibung
%		Design (Architektur)
%		Bezug zur Technologie (Plattform(un)abhängige Anforderungen)

\section{Vorüberlegungen}	\label{sec:kriterien}
	%	(Aspekte / Vorüberlegungen (Sicherheit, Verfügbarkeit, plattformspezifische Anforderungen, Usability, ?Entwickler-Komfort?, ?Feature-Reichtum?, ...))
	
 	Um nachfolgend die Exploration der ausgewählten Cross-Plattform-Technologie zu erläutern und die Eignung für die Praxis zu erörtern, sollen hier einige Vorüberlegungen getroffen werden.
 	
 	Die Anforderungen an mobile Anwendungen, sowie deren Einsatzgebiete bilden ein breites Spektrum ab. Verschiedene SDKs adressieren teilweise gezielt bestimmte Einsatzgebiete der späteren Applikation. Das führt zu der Frage, inwieweit die verwendeten Technologien für unterschiedlich motivierte Entwickler und Softwarefirmen, sowie deren Kunden, brauchbar sind. Hat ein Unternehmen beispielsweise bereits eine bestehende Software-Infrastruktur, sollte sich eine plattformunabhängige App gut in das bestehende System integrieren lassen.
 	
 	Für Entwickler und Unternehmen wiederum, kann eine plattformunabhängige Entwicklung Ressourcen sparen und somit potentiell kleineren Unternehmen den Einstieg in den Markt für mobile Anwendungen erleichtern. 
 	Ein solches Ressourcenersparnis stellt sich allerdings nur ein, wenn der Aufwand zur Einrichtung und Benutzung des Frameworks kleiner ist, als der für die Entwicklung einer separaten App für jede Plattform. 
 	Hier fließt mit ein, wie viele Zielplattformen für die Auslieferung der App angestrebt sind, sowie die Benutzerfreundlichkeit des Frameworks aus Entwicklersicht, also die Frage, wie komfortabel sich Anwendungen entwickeln lassen.
 	
 	Ein offensichtliches Kriterium zur Beurteilung des Frameworks anhand eines gegebenen Anwendungszwecks sind die zur Verfügung stehenden Features, die auf dem Mobilgerät genutzt werden können. Stimmt dieser nicht mit denen der nativen App-Entwicklung überein, ist zu klären, welche Features fehlen und auf welche der Entwickler eventuell verzichten kann oder muss.
 	
 	Weiter ist interessant, ob sich weitere potentielle Nachteile durch die Nutzung eines Frameworks zur hybriden App-Entwicklung ergeben und welche Vorteile sich heraus kristallisieren. 
 	Es ließe sich beispielsweise die Frage stellen, ob die verwendeten Web-Technologien einer hybriden App prinzipielle Stärken und Schwächen in puncto Performance haben. 
 	Hierüber wird die Beispiel-Anwendung allerdings wenig Aufschluss geben, da eine native Implementierung der gleichen Funktionen zur Vergleichbarkeit fehlt. Die Performance einer Hybrid-App ließe sich als einen Punkt der Nutzerfreundlichkeit bzw. Vor- und Nachteilen für den Endanwender sehen, was gerade für Consumer-Apps von großer Bedeutung ist.
 	
 	Weitere Vor- und Nachteile hybrider Apps ließen sich an den Fragen der Stabilität einer solchen App, also deren Fehleranfälligkeit und damit verbundenen Abstürzen der Software, sowie der Sicherheit der Software erörtern. Dies schließt die Punkte mit ein, beispielsweise durch Manipulation des bestehenden Codes, so dass Schadcode in externe Systeme oder auch Client-Geräte eingeschleust werden kann, sowie der Verschlüsselung von Datenübertragungen. 
 	Wichtig ist unter anderem die Verschlüsselung von Nutzerdaten auf dem Gerät, sowie die sichere Kommunikation der App mit externen Diensten und Geräten.
 	
 	Gerade für Client-Server-Anwendungen ist eine verschlüsselte Datenübertragung oft ein zentraler Punkt. Es lässt sich aber auch allgemeiner Fragen, wie gut sich solche Anwendungen durch hybride Apps umsetzen lassen. Gerade für eingangs erwähnte Firmen mit bestehender Infrastruktur kann dies eine wichtige Anforderung sein.
 	
 	%TODO Evtl. einige Vorüberlegungen wieder raus, weil zu viel Geschwafel und dann doch nicht ausgewertet!

\section{Beispiel-Anwendung}	\label{sec:bsp-app} 
%	Zu Explorationszwecken zu implementierender Anwendungsfall (App-Prototyp)

%\subsection{Anforderungen}
% Eine einfache app, bei der plattformunabhängigkeit sinn macht (grenzen / möglichkeiten)

% [ Minimal, weil nicht eigentliches Thema der Arbeit.: ]
% (Motivation, Idee)

% Funktionalitätsbeschreibung 
% 		Anwendungsfalldiagramm
%		Anwendungsfall beschreibung

\doubleimage[contacts]{errands-home}
	{errands-home-ios}{errands-list-ios}
	{Startbildschirm \\ der Beispielanwendung}{Listenansicht \\der Beispielanwendung}
	{Beispiel-Anwendung im iOS-Simulator}
	{Startbildschirm und Listenansicht der Beispiel-Anwendung im \gls{ios-sim}.}
	{\ownScreenshot}

Für die praktische Erprobung und Untersuchung einer Technologie zur plattformunabhängigen \gls{app}-Entwicklung sollte hier mit \gls{cordova} ansatzweise eine Beispiel-Anwendung in Form einer plattformunabhängigen mobilen \gls{app} entwickelt werden.
Für die Auswahl eines geeigneten Anwendungsgebiets war ein Kriterium die Maßgabe, möglichst solche Anforderungen der Anwendung zu identifizieren, die eine gewisse plattformspezifische Anforderung haben, also (\enquote{plattformkritische}) Features benötigen, die sich beispielsweise nicht ohne weiteres mit einer reinen Web-Anwendung umsetzen lassen, um den eigentlichen Mehrwert eines entsprechenden Cross-Plattform-Frameworks nutzen zu können und aufzuzeigen.

Dabei soll der Fokus nicht speziell auf der Umsetzung eines möglichst breiten Funktionsumfangs der Anwendung selbst oder deren Usability liegen, sondern vielmehr anhand einer beispielhaften Implementierung weniger grundlegender plattformkritischer Features die Verwendung der Cross-Plattform-Technologie erläutert werden, um Möglichkeiten und Grenzen aus Sicht des Entwicklers aufzuzeigen.

Die Beispiel-App trägt den Titel \enquote{Besorgungen}, soll also für den Anwender ein Hilfswerkzeug für die Erledigung alltäglicher Aufgaben darstellen.
Letztendlich handelt es sich um eine etwas komplexere ToDo-Liste, in der sogenannte \enquote{Tasks} (also Aufgaben, Besorgungen) in Listen kategorisiert und verwaltet werden können.
Diese Listen können vom Nutzer selbst angelegt, gelöscht und verändert werden.
Um von der Schnittstelle zum Geräte-Adressbuch gebraucht zu machen, können Listen mit im Adressbuch vorhandenen Kontakten geteilt werden, d.\,h. es sollen Kontakte aus dem Adressbuch geladen und einer Liste als neues Listenmitglied hinzugefügt werden.

Weiterhin soll ein grundlegendes Prinzip darin bestehen, dass Tasks vielerlei Eigenschaften zugewiesen bekommen können.
So zum Beispiel Fotos, die von der Kamera des Geräts aufgenommen werden sollen, Ortsangaben, um GPS-Daten zu empfangen und zu verarbeiten sowie Datumsangaben für die Interaktion mit dem nativen Kalender.
Außerdem soll die Anwendung Benachrichtigungen über das Erreichen eines angegebenen Datums oder Ortes per nativem Benachrichtigungsmechanismus des jeweiligen Betriebssystems aussenden können.\footnote{Eine detailliertere Spezifikation der Anwendungsfälle für die geplante Beispiel-App findet sich in \fullpageref{sec:af}.}
%TODO nochmal überprüfen, ob das alles so sinn macht.
Der Entwicklungsstand des hier beschriebenen Beispiel-Codes beschränkt sich jedoch auf die Umsetzung der \og Funktionalität, Listen zu teilen, also neue Listenmitglieder anhand der Daten aus der Kontaktverwaltung des Geräts zu Listenobjekten hinzuzufügen.

\section{Ausgewählte Technologie und Architektur für die Implementierung}
	%TODO Irgendwo erwähnen, welche Test-Zielplattformen ich verwendet habe. --> Evlt. auch in [impl].

Da \gls{cordova} eins der meist genutzten \glspl{framework} zur plattformunabhängigen \gls{app}-Entwicklung darstellt, das kostenfrei, \gls{opensource} und gut dokumentiert ist und zudem den Vorteil bietet, vorhandene Kenntnisse der Web-Entwicklung für die Erstellung von mobilen \glspl{app} nutzbar zu machen, wurde dieses hier für die Implementierung der in \autoref{sec:bsp-app} beschriebenen Beispiel-Anwendung und zur näheren Beleuchtung ausgewählt.
Weiterhin fand die auf \gls{jq} aufbauende Oberflächen-Bibliothek für mobile Web-Oberflächen \gls{jqm} sowie die \gls{data-binding}-Bibliothek \gls{ko} für die Umsetzung der hybriden \gls{app} hier Verwendung (\fullref{sec:hybrid-dev}).

Wie in \autoref{sec:ko} beschrieben, stellt \gls{ko} ein recht mächtiges und hilfreiches Mittel für die einfache und gut strukturierte Programmierung unter \gls{js} dar.
Der dadurch empfohlene und erleichterte Einsatz des \glspl{mvvm} und die damit einhergehende klare und leicht wartbare Struktur bildet die Grundlage für die Architektur der hier beispielhaft implementierten Anwendung.
	
Grundlegend besteht die Anwendung aus den drei in \autoref{fig:mvvm-pattern} abgebildeten Teilen \emph{\gls{view}} in Form einer \gls{html}-Seite, dem \gls{js}-Objekt \emph{\gls{model}}, das den Zugriff auf das Gerät bewerkstelligt und dessen Daten bereitstellt und dem \emph{\gls{view-model}}, welches die Eigenschaften und anzuzeigenden Daten der \gls{view} beinhaltet.
Das \gls{js}-\gls{framework} \gls{ko} hält dabei durch das \gls{data-binding} die Anzeige der Daten auf der \gls{view} mit den Daten im \gls{view-model} synchron (\seeref{sec:ko}).

Die Anbindung vom \gls{model} an das \gls{view-model} wurde hier über das \gls{observer-pattern} realisiert, mit dem eine lose Kopplung zwischen einer Komponente und deren \glspl{observer} erzielt werden kann.
Dabei registriert sich das \gls{view-model} bei dessen Initialisierung beim \gls{model} per Aufruf der Methode \lstinline|addEventListener(eventType, eventHandler)| (\seeref{lst:app:model.js}) und übergibt dabei als Parameter \enquote{\lstinline|eventType|} einen \gls{string}, der den Typ des Events angibt, auf dessen Aussendung sich das \gls{view-model} registriert sowie eine Funktion als \lstinline|eventHandler|, welche ausgeführt werden soll, sobald das Event empfangen wird (\seeref{lst:app:ViewModel.js}).
Dazu hat das \gls{model} einen Verweis auf eine \lstinline|ObserverMap|, welche die registrierten \gls{event-handler} der \gls{observer} in Listen speichert, die dem jeweiligen Ereignistyp, der bei der Registrierung angegeben wird, zugeordnet werden (\seeref{lst:app:ObserverMap.js}).

Statt also bei erfolgreicher Ausführung einer Operation die Daten direkt per Methodenaufruf an das \gls{view-model} zu übergeben, wird hier lediglich die Methode \lstinline|notifyObservers()| der \lstinline|ObserverMap| aufgerufen, wodurch die registrierten \gls{observer} über das Auftreten des Ereignisses benachrichtigt werden.
Das \gls{model} muss dabei keinerlei Kenntnis vom \gls{view-model} haben, lediglich im \gls{view-model} ist bekannt, welche Methoden des \glspl{model} aufgerufen werden können, bzw. welche Events dieses aussendet.

Durch diese lose Kopplung kann einerseits die Entwicklung erleichtert werden, da bei einer möglichen Aufteilung der Implementierung das Entwicklerteam, das für die Implementierung des \glspl{model} zuständig ist, keine Kenntnis über die Struktur des \glspl{view-model} oder gar der \gls{view} haben muss und darüber hinaus könnten auch weitere \gls{observer} auf Benachrichtigungen des \glspl{model} registriert werden, beispielsweise, um weitere Aktionen nach Auftreten eines Events durchzuführen.

Neben diesen architektonischen Aspekten wurde hier das \gls{observer-pattern} für die Kopplung zwischen \gls{model} und \gls{view-model} gewählt, da bei Anforderung der Daten durch das \gls{view-model} noch nicht bekannt ist, wann diese Daten genau zurückgeliefert werden, da das \gls{cordova}-\gls{framework} nach Aufruf einer \gls{plugin}-\gls{api}-Methode\footnote{Beispielweise \lstinline|navigator.contacts.find()| zum Anfordern der Kontaktdaten aus dem Adressbuch} ausgeführt wird (\seeref{lst:find-contacts}).} diese erst vom Gerät laden muss und so das Zurückliefern der Daten per Rückgabewert zu einem \lstinline|null|-Wert führen kann, da bei Aufruf der Methode \lstinline|findContacts()| die Daten unter Umständen noch nicht verfügbar sind (\seeref{lst:find-contacts}).
% Auskommentiert, da nicht sicher, ob das wirklich der Grund bei Cordova.
%Dazu dient auch die Übergabe eines \lstinline|onSuccess|-\glspl{handler}, der nach Erfolgreicher Ausführung der \og \gls{api}-Methode ausgeführt wird. 
%%TODO Theoretische erläuterungen zu cordova in Theorie-Teil verschieben!

\chapter{Implementierung der Geräte-Schnittstelle}	\label{sec:impl}
% Beschreibung der konkreten Umsetzung, Implementierung der wesentlichen Features mithilfe der Technologien (Funktionsweise (Wie genau bewerkstelligt \gls{framework} die Plattformunabhängigkeit / Was steckt dahinter?))

		
%\section{Zugriff auf die Kontaktverwaltung des Geräts} \label{sec:contacts}

\section{Funktionsweise}

Im Anwendungsfall \namerefH{shareList} der in \autoref{sec:bsp-app} und \fullref{sec:af} beschriebenen Beispielanwendung soll die Anforderung erfüllt werden, aus der Anwendung heraus auf das native Adressbuch des Geräts zuzugreifen, um die bestehenden Kontakte zu laden und anzuzeigen, sodass diese vom Nutzer ausgewählt werden, an die Anwendung übergeben und als neues Listenmitglied in ein Listenobjekt eingetragen werden können.

Nachdem das \gls{cordova}-Plugin \emph{Contacts}, wie in \fullref{sec:cordova} beschrieben, zur Anwendung hinzugefügt wurde, lässt sich damit der Zugriff auf die native Kontaktverwaltung des jeweiligen Betriebssystems bewerkstelligen.
Dieses bietet beispielsweise die Möglichkeit, nach bestimmten Kontakten im Adressbuch zu suchen, neue Kontakte zu erstellen und dem Adressbuch hinzuzufügen, sowie bestehende Kontakte zu entfernen oder zu duplizieren \cite{Cordova_Plugin_Registry_Contacts}.

Um Kontakte im Adressbuch zu suchen, muss im Wesentlichen die Methode \lstinline|navigator.contacts.find(fields, onSuccess, onError, options)| ausgeführt werden, wobei \lstinline|fields| die zu durchsuchenden Datenfelder repräsentiert, \lstinline|onSuccess| die Funktion angibt, die bei erfolgreicher Ausführung der \lstinline|find|-Methode ausgeführt werden soll, \lstinline|onError| den \gls{errorhandler} bei Auftreten eines Fehlers beim Suchen der Kontakte und \lstinline|options| zusätzliche Optionen wie Suchfilter oder ein \lstinline|multiple|-\gls{flag}, das angibt, ob mehrere Kontakte zurückgegeben werden sollen (\seeref{lst:find-contacts}, \linename 26).
Die \lstinline|find|-Methode wird \gls{asynchron} ausgeführt, das heißt, dass der Aufrufer nicht wissen kann, wann das Ergebnis zurückgeliefert wird, also nicht als Rückgabewert zurückgegeben werden kann, sondern bei erfolgreicher Suche an den \og \lstinline|onSuccess|-\gls{handler} übergeben wird und dort weiter verarbeitet werden kann \cite{Cordova_Plugin_Registry_Contacts}.

Da in diesem Beispiel (\autoref{lst:find-contacts}) keine bestimmten, sondern \emph{alle} Kontakte angezeigt werden sollen, wird der \lstinline|find|-Methode kein spezieller \lstinline|filter| übergeben (\linename 23). 
Ebenso ist aus dem selben Grund hier keine Einschränkung der durchsuchten Felder nötig, sodass durch der \lstinline|fields|-Parameter den Wert \lstinline|"*"| hat, und so alle Felder des \lstinline|Contact|-Objekts durchsucht werden (\linename 25).
Bei erfolgreicher Ausführung der \lstinline|find|-Methode werden die zurückgegebenen Kontaktdaten als Parameter in Form eines \glspl{array}, das die entsprechenden JavaScript-Objekte vom Typ \lstinline|Contact| beinhaltet, an die \lstinline|onSuccess|-Methode übergeben und vom \gls{model} an dessen \gls{observer} (in diesem Fall das \gls{view-model}) versendet (\linename 13). 

Der Bezeichner \lstinline|events.FOUND_CONTACTS| stellt eine String-Konstante dar, die in einem globalen Konstanten-Objekt definiert wurde und den Typ des \glspl{event} identifiziert (\seeref{lst:app:consts.js}).

	\includehtml{praxis/find-contacts.js} { label=lst:find-contacts, caption={Verwendung des \emph{Contacts}-Plugins von \gls{cordova}.}}

Die in \autoref{lst:find-contacts} per \gls{observer-pattern} versendeten Daten werden in der entsprechenden \gls{handler}-Methode an die \lstinline|contacts|-Eigenschaft des \glspl{view-model} übergeben (\autoref{lst:ViewModel-Contacts}, \linenamepl 16\,-\,18), deren Elemente (also die Kontakt-Objekte) anschließend durch das Data-Binding in der Oberfläche angezeigt werden (\su).

	\includehtml{praxis/ViewModel-Contacts.js}{label=lst:ViewModel-Contacts, caption={Wesentlicher Ausschnitt des \glspl{view-model}.},}

Die Methode \lstinline|findContacts()|, die den Aufruf zum Laden der Kontakte an das \gls{model} delegiert, wird hier per Event-Binding an die Kontakt-Komponente der Oberfläche gebunden, sodass diese jedes mal aufgerufen wird, wenn die Kontaktliste auf- oder zugeklappt wird, um die Daten aus dem \gls{model} anzufordern (\seeref{lst:contacts-ui}, \linename 3).
Durch die Bindung der Eigenschaft \lstinline|contacts| in Form eines \emph{Observable Arrays} des \glspl{view-model} (\autoref{lst:ViewModel-Contacts}, \linename 6) an die \gls{listview} der Oberfläche werden in dieser Liste alle Kontakte des Adressbuchs angezeigt (\seeref{lst:contacts-ui}, \linename 7).

	\includehtml{praxis/contacts-ui.html}{label=lst:contacts-ui, caption={\gls{ui}-Komponente zur Darstellung der Kontaktliste und Auswahl einzelner Kontakte.},}
	
	\pagebreak
	
\doubleimage[contacts]{apps-overview}
	{apps-overview-android}{apps-overview-ios}
	{Die installierte App in der \gls{android}-\glspl{app}-Übersicht.}
	{Die installierte App in der \gls{ios}-\glspl{app}-Übersicht.}
	{Die installierte App in der App-Übersicht.}
	{Nach der Ausführung des \lstinline|cordova emulate|-Befehls wird die zu testende \gls{cordova}-\gls{app} in der Übersicht des Betriebssystems im jeweiligen Emulator angezeigt.}
	{\ownScreenshot}
	
\doubleimage[contacts]{contacts-app}
	{contacts-android}{contacts-ios}
	{\gls{android}-Adressbuch.}{\gls{ios}-Adressbuch.}
	{Natives Adressbuch mit Beispiel-Kontakten}
	{Anzeige des nativen Adressbuchs mit Beispiel-Kontakten.}
	{\ownScreenshot}
	
\doubleimage[contacts]{errands-members}
	{errands-members-expanded-android}{errands-members-expanded-ios}
	{Auswahl-Dialog unter \gls{android}.}{Auswahl-Dialog unter \gls{ios}.}
	{Kontakt-Auswahl in der Anwendung}
	{Kontakt-Auswahl-Dialog für das Hinzufügen von Kontakten aus dem Adressbuch. Die Anwendung lädt die Kontakte aus dem Adressbuch des Geräts in die Auswahl-Box der Anwendung (\seeref{fig:contacts-app}).}
	{\ownScreenshot}
	
\doubleimage[contacts]{errands-selected}
	{errands-members-selected-android}{errands-members-selected-2-ios}
	{Selektierte Kontakt-Einträge unter \gls{android}.}{Selektierte Kontakt-Einträge unter \gls{ios}.}
	{Übergabe der Kontakte an die Anwendung}
	{Übergabe der Kontakte an die Anwendung: Wird ein Kontakt ausgewählt, wird dieser dem \gls{obs}-\gls{array} \lstinline|contacts| des \glspl{view-model} (\seeref{lst:ViewModel-Contacts}) hinzugefügt und als \emph{ausgewählt} in der Oberfläche markiert.}
	{\ownScreenshot}
	
	\pagebreak
	
\section{Explorationsergebnisse} \label{sec:contacts-ergebnis}
Einige Unterschiede ergeben sich bei der Verwendung des \emph{Contacts}-\glspl{plugin} zwischen den verschiedenen Zielplattformen.
So können beispielsweise nicht alle Methoden der \gls{contacts-api} auf allen mobilen Plattformen gleichermaßen ausgeführt werden.
Die hier verwendete \lstinline|find()|-Methode bietet mit der Unterstützung für \gls{android}, \gls{blackberry-os}, \gls{ff-os}, \gls{ios}, \gls{win-phone} und \gls{win8} eine relativ  breite Kompatibilität für alle größeren gängigen und mobilen Betriebssysteme.
Allerdings auch werden einige Datentypen \emph{nicht} von allen Plattformen unterstützt, so zum Beispiel das \lstinline|ContactOrganization|-Objekt\footnote{\seefullpageref{sec:cordova-grundlegendes}.}, das lediglich bei der Entwicklung für \gls{android}, \gls{blackberry-os}, \gls{ff-os}, \gls{ios} und \gls{win-phone} zur Verfügung steht, damit aber immer noch alle großen Plattformen unterstützt \cite{Cordova_Plugin_Registry_Contacts}.

Doch auch bei den unterstützten Plattformen sind einige Besonderheiten zu beachten, wenn es um die Verwendung einzelner Attribute der verschiedenen Objekttypen geht.
So ist beispielsweise das Feld \lstinline|displayName| des \lstinline|Contact|-Objekts unter \gls{ios} nicht verfügbar, sodass in diesem Fall auf das \lstinline|name|- oder \lstinline|nickname|-Feld zurückgegriffen werden muss.
Ähnliches gilt auch für weitere Objekte oder deren Methoden und Felder, die unter bestimmten Plattformen nicht oder nur teilweise unter Berücksichtigung bestimmter Besonderheiten funktionieren \cite{Cordova_Plugin_Registry_Contacts}.

So wird beispielsweise \lstinline|find|-Methode grundsätzlich mit \gls{android}, \gls{blackberry-os}, \gls{ff-os}, \gls{ios}, \gls{win-phone} und \gls{win8} von den wichtigsten mobilen \glspl{plattform} unterstützt, doch bei letzterer besteht die Einschränkung, dass aus der hybriden \gls{app} heraus nicht ohne weiteres auf die Kontaktdaten zugegriffen werden kann, wie es bei den anderen \glspl{plattform} der Fall ist (\so), sondern eine Nutzerinteraktion nötig ist, um Kontakte aus dem Adressbuch auszuwählen und weiter zu verarbeiten, sodass bei Anfrage von Kontaktdaten die \gls{app} für das native \gls{win8}-Adressbuch geöffnet wird und der Nutzer die gewünschten Kontakte selbst von Hand auswählen muss.
Darüber hinaus bieten \gls{win8}-Kontakte lediglich einen Lesezugriff, sodass hier aus der Kontaktdatenbank geladene Objekte nicht verändert, gelöscht oder dupliziert werden können \cite{Cordova_Plugin_Registry_Contacts}.

Eine Kategorisierung von Kontakten über das \lstinline|cagegories|-Attribut wird bei \gls{ff-os} sowie \gls{ios} nicht unterstützt, sodass beim Versuch, diesen Wert anzufragen, \lstinline|null| zurückgegeben wird.
In Bezug auf die Unterstützung des \lstinline|Contact|-Objekts ergeben sich die meisten Einschränkungen für die Plattform \gls{win-phone}.
Hier finden sich in der \gls{contacts-api}-Dokumentation beispielsweise Informationen über ein teilweise leicht inkonsistentes Verhalten beim Erstellen bzw. Suchen von Kontakten.
So unterscheidet sich beispielsweise der Wert des \lstinline|displayName|-Attributs, das bei Erstellung eines \lstinline|Contact|-Objekts angegeben wird von dem, das bei der Suche zurückgeliefert wird.
Ebenso können bei der Erstellung eines \lstinline|Contact|-Objekts mehrere \glspl{url} angegeben werden, während bei den Objekten des Suchergebnisses nach Ausführung der \lstinline|find|-Methode lediglich \emph{eine} verfügbar ist.

Einige Listenfelder des \lstinline|Contact|-Objekts besitzen ein Attribut mit dem Namen \lstinline|pref|, dem ein boolescher Wert zugewiesen kann, der angibt, ob das jeweilige Objekt innerhalb einer Liste\footnote{So beispielsweise bei den Feldern \lstinline|emails|, \lstinline|phoneNumbers| oder \lstinline|addresses|, denen jeweils mehrere E-Mail-Adressen, Telefonnummern bzw. Adressen zugewiesen werden können.} das vom Nutzer präferierte darstellt.
Dieses \lstinline|pref|-Attribut wird ebenfalls unter einigen Plattformen nicht unterstützt, so \zB für \lstinline|phoneNumbers| und \lstinline|emails| unter \gls{win-phone} sowie beim \lstinline|addresses|-Feld unter \gls{android}\,2.X, \gls{blackberry-os}, \gls{ios} und \gls{win8}.
Die \lstinline|Contact|-Felder \mbox{\lstinline|note|,} \mbox{\lstinline|ims|,} \lstinline|birthdays| und \lstinline|categories| werden für \gls{win-phone} gar nicht unterstützt.

Das \og \lstinline|Contact|-Feld \lstinline|name| hat den Datentyp \lstinline|ContactName| und besteht aus den weiteren \gls{string}-Attributen \mbox{\lstinline|formatted|,} \mbox{\lstinline|familyName|,} \mbox{\lstinline|code|,} \mbox{\lstinline|middelName|,} \lstinline|honorificPrefix| und \lstinline|code|.
Grundlegend wird dieses Objekt zwar von allen elementaren Plattformen unterstützt, doch auch hier gibt es einige Einschränkungen.
Das \lstinline|formatted|-Attribut wird unter \gls{android}, \gls{blackberry-os}, \gls{ff-os} und \gls{ios} nur teilweise unterstützt und bietet für \gls{android}, \gls{ios} sowie \gls{ff-os} lediglich einen Lesezugriff.
Unter \gls{win8} stellt dieses das einzige Attribut des \lstinline|ContactName|-Objekts dar, alle anderen werden nicht unterstützt.

Während bei der nativen App-Entwicklung für \gls{ios} oder \gls{android} \gls{ui}-Kom\-po\-nen\-ten für die Arbeit mit Kontakten bereitstehen, liefert die \gls{contacts-api} hier lediglich Mechanismen für den Zugriff auf die Kontaktdaten, jedoch nicht die entsprechenden UI-Komponenten, da diese vom jeweiligen verwendeten \gls{gui}-Toolkit abhängen.
Die hier verwendete Oberflächen-Bibliothek \gls{jqm} beinhaltet lediglich allgemeine \glspl{widget} wie Listen, Buttons, Tabellen etc., sodass die Erstellung einer \gls{ui}-Komponente für die Auswahl von Kontakten dem Entwickler überlassen bleibt.

In Verbindung mit der Data-Binding-Bibliothek \gls{ko} kann eine solche Komponente jedoch relativ einfach erstellt werden, indem die Felder in der Oberfläche an Eigenschaften des \glspl{view-model} gebunden werden, welches durch Benachrichtigungen des Models, das den Zugriff auf die native Ebene des Betriebssystems abwickelt, die Daten der Anwendung und des Geräts anzeigen kann (\seeref{sec:ko}).

Grundsätzlich bietet die \gls{contacts-api} trotz einiger Einschränkungen (\so) ein nützliches Werkzeug mit einem relativ breiten Funktionsumfang für den grundlegenden Zugriff auf die Kontaktverwaltung der meisten großen mobilen Betriebssysteme.
Der für dieses Feature definierte Anwendungsfall konnte mit den Mitteln der \gls{cordova}-\gls{api} und weiteren Technologien der Webentwicklung wie \gls{ko} oder \gls{jqm} gut für die hier verwendeten Plattformen \gls{ios} und \gls{android} umgesetzt werden.
Trotz des grundsätzlich plattformunabhängigen Ansatzes sollte allerdings bei der Entwicklung mithilfe dieser \gls{api} die Unterstützung der verwendeten Features und Attribute und deren Besonderheiten für die angestrebten Zielplattformen in der \gls{contacts-api}-Dokumentation überprüft werden.
Somit ist eine Kenntnis über die angestrebten Zielplattformen für die Verwendung eines solchen \glspl{plugin} beinahe unabdingbar und die Entwicklung spezieller Funktionalitäten in gewisser Weise wieder ein Stück weit abhängiger von den verwendeten Plattformen. %TODO Den Satz evtl. auch ins Fazit!

%TODO Dopplungen / Gliederung checken!!

%			Explorationsergebnisse
%			Grenzen und Möglichkeiten bei der Umsetzung (Nach jeder Feature-Beschreibung)
%				Aha-Erlebnisse
%				Konkrete Quellcode-Beispiele
%				Ecken und Kanten, Spitzfindigkeiten zeigen 
%				Eigenschaften, Was fällt auf ? Am Beispiel

\chapter{Auswertung und Eignung für die Praxis} % Zusammenfassung der Erfahrung Umsetzung
%		Benutzung (Technik, Methodik, Entwicklerfreundlichkeit, Kompatibilität mit anderen Systemen / Software)
%		Generelle Bewertung des Frameworks und der Technologie sowie 
%		Vor-/Nachteile (zueinander / gegenüber nativer App-Entw.), Risiken, Chancen
%TODO In \cite{Apache_Cordova_Contribute} werden noch einige Plattformen mehr aufgelistet. (wohl je nach cordova-version) -> evlt. hier auch noch erwähnen und/oder auflisten.

%TODO Kommentare aus GoogleDocs einfügen!

%TODO Evtl. eher ins Resümee?
An dem Implementierungsbeispiel der Schnittstelle zur Adressverwaltung konnte gezeigt werden, dass die \gls{cordova}-\gls{api} grundsätzlich einen grundlegenden Funktionsumfang für die Interaktion zwischen der hybriden App und nativen Betriebssystemfunktionalitäten bietet.

So konnte der zuvor gesetzte Anwendungsfall \nameref{shareList}, in dem primär Kontakte aus dem Adressbuch des Geräts geladen und der Anwendung hinzugefügt werden sollten, für beide getestete Betriebssysteme \gls{android} und \gls{ios} gut umgesetzt werden. 
Allerdings sind, wie in \autoref{sec:impl} beschrieben, auch einige Besonderheiten bzgl. des Umgangs mit verschiedenen \gls{js}-Objekten, die die api mitbringt, sowie der Verwendung von verschiedenen Attributen auf unterschiedlichen Plattformen angeht, zu beachten.

Im hier implementierten Praxis-Beispiel konnte beispielsweise nicht auf das displayName-Attribut des Contact-Objekts zugegriffen werden, da die Anwendung sowohl unter android als auch unter ios laufen sollte und wie in \autoref{sec:contacts-ergebnis} beschrieben, dieses unter ios nicht zur Verfügung steht. Unter anderem mit dem name-Attribut bietet die contacts-api jedoch Ausweichmöglichkeiten, sodass diese Einschränkung kein Problem für Umsetzung des Anwendungsfalls darstellte.
Soll also sehr detailliert mit Objekten größerer Geräteschnittstellen wie \zB Kontakten gearbeitet werden, ist mindestens eine vorherige genaue Prüfung der unterstützten Eigenschaften nötig. In speziellen Fällen können bestimmte Anforderungen auch nicht umgesetzt werden, wie beispielsweise die Bearbeitung vieler oder einiger Kontakt-Details unter bestimmten mobilen Plattformen (\seeref{sec:contacts-ergebnis}).

Ein Nachteil der Implementierung als Hybrid-App gegenüber der nativen Entwicklung ist sicherlich das in \fullref{sec:contacts-ergebnis} erwähnte Fehlen von entsprechenden \gls{gui}-Komponenten für einen konkreten Anwendungsfall (beispielsweise \emph{Kontakte auswählen}). 
Diese ist jedoch auch durch die flexible Einsetzbarkeit der Hybrid-Technologie mit deren Kombination aus verschiedensten durch den Entwickler ausgewählten Web-Technologien begründet. 
So entsteht hier zumindest dadurch ein Mehraufwand, dass Entwickler mehr als bei der nativen App-Entwicklung, wo verschiedenste Widgets der jeweiligen Plattform für die Umsetzung konkreter Anwendungsfälle bereit stehen, in die Auswahl von geeigneten GUI-Bibliotheken und anderen Hilfsmitteln oder gar die Entwicklung eigener UI-Komponenten investieren müssen.

Wie in \autoref{sec:contacts-ergebnis} erwähnt, kann unter \gls{win8} nicht programmatisch auf das Adressbuch für die Auswahl von Kontakten zugegriffen werden, diese müssen also vom Nutzer in der \gls{win8}-Adressbuch-Applikation händisch ausgewählt werden.
In der Dokumentation findet sich allerdings kein Hinweis, ob dieses Prozedere auch unter anderen Plattformen als Workaround für die Auswahl von Kontakten genutzt werden kann, erscheint für eine bloße Auswahl von Kontaktobjekten durch den Nutzer diese Interaktion mit einer anderen nativen App doch durchaus praktikabel, gerade vor dem Hintergrund des Ziels eines möglichst erwartungskonformen (hier also möglichst nativen) \glspl{look-and-feel}. 

% Cordova generell (siehe Kriterien):
% Performance 
Wie in \autoref{sec:kriterien} erläutert, lässt sich über die Performance der Hybrid-App hier keine klare Angabe machen, da durch die Konzeption der ausschließlich hybriden App-Implementierung keine Vergleichswerte mit einer entsprechenden nativen App vorliegen.
Im Praxis-Test scheint die Oberfläche der hybriden \gls{js}-App allerdings vom ersten Eindruck her vor allem auf dem Android-Gerät etwas langsamer zu laufen als man es von einer einfachen mobilen App, wie sie hier prototypisch umgesetzt wurde, erwarten würde.

Andere Quellen berichten hier jedoch auch von differenzieren und hiervon abweichenden Ergebnissen, so beispielsweise ein Performance-Test, der mit der Erzeugung einer großen Anzahl von Objekten im Speicher sowie der Berechnung der 30. Fibonacci-Zahl unter verschiedenen mobilen Betriebssystemen jeweils in \gls{js}- und nativem Code und in die Performance-Unterschiede von Hybrid-Apps der unterschiedlichen Plattformen misst (\seeref{fig:performance}).
Dabei lässt sich keine klare Aussage über die Performance von Hybrid-Apps machen, da die Testergebnisse auf den unterschiedlichen Plattformen sehr unterschiedlich ausfallen:

\begin{quoting}
	\enquote{Der in Phonegap-Apps implementierte Javascript-Code wird je nach Zielplattform unterschiedlich schnell ausgeführt. Auf Android-Geräten ist Javascript der nativen Implementierung sogar überlegen. Unter iOS ist die native Variante rund neunmal schneller als Javascript, unter Windows Phone 7 sogar 50-mal. Ein weiterer Performance-Test zeigt, dass das Erzeugen von Objekten unter Javascript auf allen Plattformen wesentlich performanter abläuft als in den jeweiligen nativen Sprachen.}~\cite{Eine_App_fr_alle_Plattformen_-_IT_Magazine}
\end{quoting}
	
\image{performance}
	{width=\fullimagesize}
	{Vergleich Ausführungsgeschwindigkeit}
	{Vergleich der Ausführungsgeschwindigkeit von Berechnungen durch nativen und \gls{js}- bzw. Ruby-Code auf unterschiedlichen mobilen Plattformen. In diesem Test zeigt \gls{js} vor allem auf \gls{android}-Geräten eine besonders gute Performance (schneller als nativ), bei \gls{ios} und vor allem \gls{win-phone} dagegen ist der native Code deutlich schneller.}
	{Swiss IT Magazine \cite{PerformanceTabelle}.}

% Brauchbarkeit für unterschiedlich motivierte Entwickler / Unternehmen

% Für Unternehmen mit einer bestehenden Software-Infrastuktur

Die Eignung des Hybrid-App-Frameworks Cordova für Unternehmen mit einer bestehenden Anwendungsinfrastuktur, wie beispielsweise einem komplexeren Client-Server-System, hängt unter anderem davon ab, ob bereits ein gewisses Know-How der Entwickler im Bereich der Web-Entwicklung oder der generellen Entwicklung von mobilen Apps vorliegt. 
Muss dieses Know-How erst noch aufgebaut werden, wird hier eine Kosten-Nutzen-Abwägung über den dadurch entstehenden Mehraufwand nützlich sein.

% Kann eine solche plattformunabhängie App einfach und gut in das bestehende System intergriert werden?

Eine Hybride-App durchaus in ein bestehenden System integriert werden, sofern die Verarbeitungslogik Anfragen verarbeiten kann, die mit \gls{js} erstellt werden können, wie, im \zB bei der integration in eine Client-Server-Anwendung, mittels der \gls{ajax}-Technologie zur asynchronen Datenübertragung.
Besteht also nicht die Anforderung einer Offline-Nutzbarkeit der zu entwickelnden App, so muss nicht, wie in dem hier aufgezeigten Praxis-Beispiel angedeutet, die Verabeitungslogik in \gls{js} neu implementiert werden, sondern kann als bestehende Client-Server-Architektur weiter genutzt werden, indem die mit Cordova und entsprechenden Web-Technologien entwickelte App den Client darstellt und (beispielsweise per \gls{ajax}-Anfragen) mit der Server-Anwendung kommuniziert.


% [Spezielle Geräte- und Peripherie-Anforderungen, die evtl. nicht vom Standard-Funktionsumfang von Cordova abgedeckt werden]

Durch das offene und modulare Prinzip von Cordova, je nach benötigtem Feature das entsprechende Plugin aus der Cordova-Plugin-Registry, PlugReg oder ähnlichen Pools, die durch viele Dritt-Entwickler mit Plugins versorgt werden, zu laden und der Anwendung hinzuzufügen, kann bereits ein sehr breites Spektrum an Gerätespezifischen Anforderungen erfüllt werden.
Besteht darüber hinaus Bedarf an der Nutzung von bisher nicht unterstützten Geräteeigenschaften und Funktionalitäten, können Entwickler die entsprechenden Schnittstellen mithilfe des in der Cordova-Dokumentation bereitgestellten \gls{plugin-dev-guide} in Form von weiteren selbst erstellten Plugins implementieren. 

% Feature-Reichtum: Wieviel geht überhaupt damit?

% Auch hier wieder: im zweifelsfalls können plugins selbst geschrieben werden.

allerdings haben selbst die von cordova mitgelieferten Kern-Plugins, die großteils bereits ein breites Spektrum an Betriebssystemen bedienen, teilweise ihre Einschränkungen in der Nutzbarkeit auf unterschiedlichen Plattformen, es kann also die Vermutung angestellt werden, dass auch bei der Entwicklung eigener Plugins Schwierigkeiten in der Unterstützung von detaillierten Objekteigenschaften und Geräte-Features auftreten können, die sich nicht ohne weiteres mit \gls{js} umsetzen lassen. 
Als Ursache für diese Einschränkungen liegt allerdings vor allem auch die Vermutung nahe, dass bei der Definition von Datentypen, die Objekte verschiedener Plattformen abbilden sollen, stets nur der kleinste gemeinsame Nenner gefunden werden kann und so beispielsweise Datenfelder, die nur Objekttypen einer bestimmten Plattform beinhalten, bei anderen Plattformen entweder auf andere Attribute gemappt werden müssen oder schlicht nicht zur Verfügung stehen. 

% Ist der Vergleichbar mit der nativen App-Entwicklung?

Das kommt wieder sehr stark darauf an, was man vorhat (siehe oben, hiervor).
Grundsätzlich lässt sich festhalten, dass durch das modular erweiterbare Prinzip der Cordova-Plugins eine nahezu vollständige Unterstützung einer speziellen Zielplattform durch die Hybrid-App mit eventuellem Zusatzaufwand durchaus bewerkstelligen lässt. 
Durch unterschiedliche Datenmodelle der verschiedenen Plattformen müssen jedoch bei der Verarbeitung von komplexeren Datenobjekten Attribute auf unterschiedliche Strukturen der jeweiligen Plattformen gemappt und in einen möglichst generischen Objektraum von \gls{js}-Objekten abstrahiert werden, sodass hier wieder Einschränkungen in der vollständigen Nutzbarkeit von Datentypen entstehen können (siehe oben, “Feature-Reichtum” / [sec:contacts]).

% Für Entwickler und kleine Unternehmen, die sich mit möglichst geringem Aufwand am Markt für mobile Anwendungen etablieren wollen

Für Entwickler und kleine Unternehmen, die sich mit möglichst geringem Aufwand am Markt für mobile Anwendungen etablieren wollen, stellt sich die Frage nach der Eignung der Verwendung einer solchen Cross-Plattform-Technologie vor allem anhand der Zielsetzung bzgl. der Vielfalt von zu bedienenden Zielplattformen.

Soll ohnehin nur eine Plattform erreicht werden,\footnote{beispielsweise in dem Fall, dass mit bereits vorhandenen Kenntnissen in der Web-Entwicklung eine mobile App entwickelt werden soll oder die möglichkeit offen gehalten werden soll, die App zu einem späteren Zeitpunkt auch für mehrere Plattformen angeboten werden soll} so ist der Entwicklungsaufwand vermutlich vergleichbar dem für die Entwicklung einer nativen App, da der Code in beiden Fällen (sowohl bei der nativen als auch für die Hybrid-App) einmal geschrieben werden muss %TODO (siehe auch unten “welche nachteil ergeben sich” -> wenn schon eine app da, müsste die als hybrid-app nochmal geschrieben werden).
Bei einer Zielsetzung möglichst breiter Plattformunterstützung sowie relativ geringer geräte- und plattformspezifischer Anforderungen ist 
Selbst mit der Maßgabe einer Implementierung von Schnittstellen zu Gerätefunktionalitäten ist in vielen Fällen die Entwicklung einer Hybriden App lohnenswert, da, wie [oben] beschrieben, durch die Vielfalt an Cordova-Plugins die meisten grundlegenden Features auf verschiedenen Plattformen umsetzbar sind. 

% Welche Nachteile ergeben sich durch die hybride App-Entwicklung?

Gerade für Entwickler, die mit ihren Kenntnissen in der mobilen App-Entwicklung bereits herkömmliche Apps entwickelt oder gar am Markt etabliert haben, kann der Umstieg auf die hybride App-Entwicklung unter Umständen schwierig sein, da hier der komplette Entwicklungsaufwand für die Neuentwicklung einer bereits bestehenden Software noch einmal anfällt und evt. die Anwendungsentwicklung mit Web-Technologien neu erlernt werden muss.

% Welche Vorteile ergeben sich in der Entwicklung?

%TODO  Code nur einmal schreiben, aber für mehrere Plattformen ausliefern.

%TODO Kenntnisse in der Web-Entwickung können auch für die mobile App-Entwcklung weiter genutzt werden

% Welche Vor- und Nachteile ergeben sich für den Endanwender?
%TODO - Look-And-Feel nicht wie sonstige (native) Apps
%TODO - Evtl. Geschwindigkeitseinbußen durch langsamere \gls{js}-Interpretation als ausführung von kompiliertem Binärcode 
%TODO + Durch breitere Plattformunterstützung ist für viele Anwender die wahrscheinlichkeit höher, dass die entwickelte App auch für ihr Betriebssystem zur Verfügung steht
% TODO [....] evlt. noch mehr? 

% Benutzerfreundlichkeit aus Entwicklersicht: Lässt sich mithilfe den verwendeten Technologien gut eine Anwendung entwickeln?

%TODO Ein Knackpunkt ist die auswhal einer geeignete IDE:
%TODO Gibt sehr viele, auch teilweise unterschiedliche ansätze
außerdem muss für die App-Entwicklung mit Web-Technologien einr geeignete GUI-Bibliothek ausgewählt und integriert werden, wo wieder viele verschiedene Lösungen zur Verfügung stehen.
Darüber hinaus ist es ratsam, für eine klare und gut wartbare Struktur des \gls{js}-Codes auf weitere Bibliotheken wie beispielsweise [ko] zurückzugreifen, die Mechanismen wie Data-Binding oder Dependency Tracking übernehmen, da der eigentliche \gls{js}-Kern zwar einige aus vielen Programmiersprachen bekannte Konzepte wie eine ansatzweise Objektorientierung beinhaltet und generell durch seine mit vielen anderen Programmiersprachen wie beispielsweise Java oder \gls{c-sharp} ähnlichen Syntax und weiten Verbreitung grundsätzlich gut programmieren lässt, jedoch auch einige Mechanismen, \zB für größere Projekte, vermissen lässt.
So ist \gls{js} beispielsweise nicht typsicher [gls], sodass bei der Verwendung von Schnittstellenmethoden beispielsweise nicht durch einen Compiler angezeigt werden kann, welchen Typ eine Rückgabewert hat, der ausschließliche zugriff auf Schnittstellen-Eiegnschaften also nicht durch den compiller erzwungen werden kann und der Programmierer eine sehr genauer Kenntnis über Eigenschaften von verwendeten Objekten haben muss.

Doch auch hier gibt es wieder alternativen und Hilfmittel wie \zB die in [sec:uebersicht] beschriebene Multiplattform-Programmiersprache Haxe, die es dem Entwickler erlauben, Mechanismen wie Typsicherheit,Vererbung, Enumaerations etc. zu verwenden, die dann in herkömmlichen \gls{js}-Code übersetzt werden und somit allen gängigen Browsern bzw. WebViews kompatiblen Code interpretiert und ausgeführt werden kann.

Die Erstellung von hybriden Apps mithilfe des Cordova-Frameworks ist durch die [oben] beschriebenen Hilfsmittel durchaus recht praktikabel, wirkt aber im Vergleich zur nativen App-Entwicklung in gewisser Weise ein wenig umständlicher, da zumindest bei der Entwicklung für die beiden größten Plattformen Android und iOS komplette SKDs bereitstehen, die neben einer ide, die durch das entsprechende SDK alle notwendigen Bibliotheken wie GUI-Toolkits und andere komponenten für native App-Entwicklung und die Umsetzung plattformspezifischer Anforderungen auch gleich die passenden Emulatoren sowie Schnittstellen zu an den Entwicklungsrechner angeschlossene Testgeräte für die Ausführung der zu entwickelnden App mitliefern.

%TODO Außerdem: Verwaltungsaufwand für die unterschiedlichen SDKs der jeweiligen Zielplattformen!
%TODO -> Dazu: Abhilfe: Build-Server oder Cloud-Build-Services wie PhoneGap Build. 
%TODO Aber auch hier gibt es wieder Einschränkungen, was beispielsweise die Unterstützung bestimmter oder vieler verschiedener Plattformen. 

Der Standard-Workflow für die hybride App-Entwicklung mit Cordova sieht keine spezielle IDE für die Entwicklung des Codes vor, was den Vorteil hat, dass Entwickler sehr flexibel entscheiden können, welche Entwicklungs-Werkzeuge verwendet werden sollen und sicherlich for allem darin begründet ist, dass, im Gegensatz zu reinen SDKs für die native App-Entwicklung, Cordova lediglich die Schnittstelle zwischen der entwickelten Web-App und dem Gerät bildet und bis auf die Festlegung auf den weit verbreiteten \gls{js}-Standard ansonsten relativ unabhängig von weiteren verwendeten Technologien ist.

Dies bietet Entwicklern zwar ein hohes Maß an Flexibilität und Entscheidungsfreiheit, andererseits müssen dadurch nützliche Werkzeuge für die Software-Entwicklung sozusagen stets selbst zusammen gestellt werden, indem beispielsweise neben einer IDE, unter Umständen mit entsprechenden Plugins für die verwendeten Web-Technologien, weitere geeignete Werkzeuge wie beispielsweise das Debugging-Tool Weinre für das Remote-Debuggen einer hybriden App in einem Emulator oder einem entfernten Gerät, den browser-basierten Emulator für das Test von mit Cordova erstellten Hybrid-Apps oder grafische GUI-Designer einzeln recherchiert, installiert und verwendet werden müssen. 

Darüber hinaus gibt es aber auch Lösungen, die die verschiedenen Tools zusammenführen und so eine Art Komplett-SDK schaffen, sodass Entwickler hybrider Apps nicht zwangsläufig aus verschiedensten Tool wie Code-Editoren, IDE-Plugins, Debugging-Tools und Emulatoren und die passendsten auswählen müssen, sondern mit Komnbinationsläsungen sofort eine Art ”Werkzeugkasten”  Mit allen oder zumindest vielen wichtigen Tools, wie den oben genannten und sogar grafische GUI-Design-Werkzeuge, vorfinden.

%TODO	Sencha (???)

%TODO	DaVinci Studio

%TODO	Intel XDK

Allerdings haben sich die hier im Praxis-Test ansatzweise ausprobierten SDKs trotz vielversprechender Features eher nicht als besonders brauchbar erwiesen, da eine der Lösungen, DaVinci Studio, nur mit einer relativ alten Cordova-Version aus dem Jahre 2012 ausgestattet ist und das sehr flexible Intel XDK von Hand editierte Änderungen im HTML-Oberflächen-Quelltext bei einer Bearbeitung der GUI durch den mitgelieferten grafischen GUI-Designer überschreibt.

% Flexibilität und Erweiterbarkeit 
%TODO s. oben: kombinierbar m. versch. techs
%TODO durch plugins und opensource sehr gut erweiterbar
%TODO Opensource: Da \gls{js}-Code nicht kompiliert, also in maschinenlesbaren Code übersetzt, sondern lediglich durch einen Interpreter interpretiert wird, ist der mit \gls{js} entwickelte Teil der Anwendung im normalfall per se quelloffen. 
% Dritte könnten also den so geschriebenen Quellcode der App durch das Entpacken des jeweiligen installierbaren Archiv-Pakets einsehen.
% Für die Entwicklung von Closed-Source-Produkten kann es also unter Umständen ein Problem darstellen, wenn [....]

%TODO Risiken

%TODO % Chancen

% Sicherheit:

% Gibt es Verschlüsselungsmechanismen für die Datenübertragung bei den Verwendeten Technologien?
% TODO Bisher nichts gefunden.

% Wie leicht lassen sich Hybrid-Apps hacken (also beispielsweise den bestehenden Code, so verändern, dass Schadcode in externe Systeme oder auch Clientgeräte eingeschleust werden kann)?

%TODO Durch offenen \gls{js}-Code evtl. schon -> Quelle????

Im Normalfall können ajax-Anfragen aus sicherheitsgründen nicht an entfernte Systeme gestellt werden, entsprechender \gls{js}-Code liegt also üblicherweise in der Web-Entwicklung auf dem gleichen Server wie die Verarbeitungsinstanzen. 
Für den Anwendungsfall im Cordova-Umfeld, auch von einer mobilen (hybriden) App, die als Client fungiert, mit einem Server zu kommunizieren, gibt es hier den Mechanismus [...], der diese Einschränkung aufhebt. %TODO ausformuliren!!

% Stabilität

% Kann es leicht zu fehlern kommen, die einen Absturz der Software oder ähnliches provozieren können?
% TODO [ Auch bisher keine Quellen, auch nicht ausprobiert. ]



















