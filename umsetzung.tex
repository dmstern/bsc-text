\part{Praktische Umsetzung} \label{sec:praxis} 
% (mein Anteil)  verweis auf technische grundlagen.

\chapter{Konzeption}	
%		Idee, Anforderungen -> plattformunabhägig
%		Funktionalitätsbeschreibung
%		Design (Architektur)
%		Bezug zur Technologie (Plattform(un)abhängige Anforderungen)

\section{Kriterien zur Bewertung}	\label{sec:kriterien}
	%	(Aspekte / Vorüberlegungen (Sicherheit, Verfügbarkeit, plattformspezifische Anforderungen, Usability, ?Entwickler-Komfort?, ?Feature-Reichtum?, ...))

\section{Beispiel-Anwendung}	\label{sec:bsp-app} 
%	Zu Explorationszwecken zu implementierender Anwendungsfall (App-Prototyp)

%\subsection{Anforderungen}
% Eine einfache app, bei der plattformunabhängigkeit sinn macht (grenzen / möglichkeiten)

% [ Minimal, weil nicht eigentliches Thema der Arbeit.: ]
% (Motivation, Idee)

% Funktionalitätsbeschreibung 
% 		Anwendungsfalldiagramm
%		Anwendungsfall beschreibung

Für die praktische Erprobung und Untersuchung einer Technologie zur plattformunabhängigen \gls{app}-Entwicklung sollte hier mit \gls{cordova} ansatzweise eine Beispiel-Anwendung in Form einer plattformunabhängigen mobilen \gls{app} entwickelt werden.
Für die Auswahl eines geeigneten Anwendungsgebiets war ein Kriterium die Maßgabe, möglichst solche Anforderungen der Anwendung zu identifizieren, die eine gewisse plattformspezifische Anforderung haben, also (\enquote{plattformkritische}) Features benötigen, die sich beispielsweise nicht ohne weiteres mit einer reinen Web-Anwendung umsetzen lassen, um den eigentlichen Mehrwert eines entsprechenden Cross-Plattform-Frameworks nutzen zu können und aufzuzeigen.

Dabei soll der Fokus nicht speziell auf der Umsetzung eines möglichst breiten Funktionsumfangs der Anwendung selbst oder deren Usability liegen, sondern vielmehr anhand einer beispielhaften Implementierung weniger grundlegender plattformkritischer Features die Verwendung der Cross-Plattform-Technologie erläutert werden, um Möglichkeiten und Grenzen aus Sicht des Entwicklers aufzuzeigen.

Die Beispiel-App trägt den Titel \enquote{Besorgungen}, soll also für den Anwender ein Hilfswerkzeug für die Erledigung alltäglicher Aufgaben darstellen.
Letztendlich handelt es sich um eine etwas komplexere ToDo-Liste, in der sogenannte \enquote{Tasks} (also Aufgaben, Besorgungen) in Listen kategorisiert und verwaltet werden können.
Diese Listen können vom Nutzer selbst angelegt, gelöscht und verändert werden.
Um von der Schnittstelle zum Geräte-Adressbuch gebraucht zu machen, können Listen mit im Adressbuch vorhandenen Kontakten geteilt werden, d.\,h. es sollen Kontakte aus dem Adressbuch geladen und einer Liste als neues Listenmitglied hinzugefügt werden.

Weiterhin soll ein grundlegendes Prinzip darin bestehen, dass Tasks vielerlei Eigenschaften zugewiesen bekommen können.
So zum Beispiel Fotos, die von der Kamera des Geräts aufgenommen werden sollen, Ortsangaben, um GPS-Daten zu empfangen und zu verarbeiten sowie Datumsangaben für die Interaktion mit dem nativen Kalender.
Außerdem soll die Anwendung Benachrichtigungen über das Erreichen eines angegebenen Datums oder Ortes per nativem Benachrichtigungsmechanismus des jeweiligen Betriebssystems aussenden können.
%TODO nochmal überprüfen, ob das alles so sinn macht.
Der Entwicklungsstand des hier beschriebenen Beispiel-Codes beschränkt sich jedoch auf die Umsetzung der \og Funktionalität, Listen zu teilen, also neue Listenmitglieder anhand der Daten aus der Kontaktverwaltung des Geräts zu Listenobjekten hinzuzufügen.

\doubleimage[contacts]{errands-home}
	{errands-home-ios}{errands-list-ios}
	{Startbildschirm \\ der Beispielanwendung}{Listenansicht \\der Beispielanwendung}
	{Beispiel-Anwendung im iOS-Simulator}
	{Startbildschirm und Listenansicht der Beispiel-Anwendung im \gls{ios-sim}.}
	{\ownScreenshot}

\section{Ausgewählte Technologie und Architektur}

Da \gls{cordova} eins der meist genutzten \glspl{framework} zur plattformunabhängigen \gls{app}-Entwicklung darstellt, das kostenfrei, \gls{opensource} und gut dokumentiert ist und zudem den Vorteil bietet, vorhandene Kenntnisse der Web-Entwicklung für die Erstellung von mobilen \glspl{app} nutzbar zu machen, wurde dieses hier für die Implementierung der in \autoref{sec:bsp-app} beschriebenen Beispiel-Anwendung und zur näheren Beleuchtung ausgewählt.
Weiterhin fand die auf \gls{jq} aufbauende Oberflächen-Bibliothek für mobile Web-Oberflächen \gls{jqm} sowie die \gls{data-binding}-Bibliothek \gls{ko} für die Umsetzung der hybriden \gls{app} hier Verwendung (\fullref{sec:hybrid-dev}).

Wie in \autoref{sec:ko} beschrieben, stellt \gls{ko} ein recht mächtiges und hilfreiches Mittel für die einfache und gut strukturierte Programmierung unter \gls{js} dar.
Der dadurch empfohlene und erleichterte Einsatz des \glspl{mvvm} und die damit einhergehende klare und leicht wartbare Struktur bildet die Grundlage für die Architektur der hier beispielhaft implementierten Anwendung.
	
Grundlegend besteht die Anwendung aus den drei in \autoref{fig:mvvm-pattern} abgebildeten Teilen \emph{\gls{view}} in Form einer \gls{html}-Seite, dem \gls{js}-Objekt \emph{\gls{model}}, das den Zugriff auf das Gerät bewerkstelligt und dessen Daten bereitstellt und dem \emph{\gls{view-model}}, welches die Eigenschaften und anzuzeigenden Daten der \gls{view} beinhaltet.
Das \gls{js}-\gls{framework} \gls{ko} hält dabei durch das \gls{data-binding} die Anzeige der Daten auf der \gls{view} mit den Daten im \gls{view-model} synchron (\seeref{sec:ko}).

Die Anbindung vom \gls{model} an das \gls{view-model} wurde hier über das \gls{observer-pattern} realisiert, mit dem eine lose Kopplung zwischen einer Komponente und deren \glspl{observer} erzielt werden kann.
Dabei registriert sich das \gls{view-model} bei dessen Initialisierung beim \gls{model} per Aufruf der Methode \lstinline|addEventListener(eventType, eventHandler)| (\seeref{lst:app:model.js}) und übergibt dabei als Parameter \enquote{\lstinline|eventType|} einen \gls{string}, der den Typ des Events angibt, auf dessen Aussendung sich das \gls{view-model} registriert sowie eine Funktion als \lstinline|eventHandler|, welche ausgeführt werden soll, sobald das Event empfangen wird (\seeref{lst:app:ViewModel.js}).
Dazu hat das \gls{model} einen Verweis auf eine \lstinline|ObserverMap|, welche die registrierten \gls{event-handler} der \gls{observer} in Listen speichert, die dem jeweiligen Ereignistyp, der bei der Registrierung angegeben wird, zugeordnet werden (\seeref{lst:app:ObserverMap.js}).

Statt also bei erfolgreicher Ausführung einer Operation die Daten direkt per Methodenaufruf an das \gls{view-model} zu übergeben, wird hier lediglich die Methode \lstinline|notifyObservers()| der \lstinline|ObserverMap| aufgerufen, wodurch die registrierten \gls{observer} über das Auftreten des Ereignisses benachrichtigt werden.
Das \gls{model} muss dabei keinerlei Kenntnis vom \gls{view-model} haben, lediglich im \gls{view-model} ist bekannt, welche Methoden des \glspl{model} aufgerufen werden können, bzw. welche Events dieses aussendet.

Durch diese lose Kopplung kann einerseits die Entwicklung erleichtert werden, da bei einer möglichen Aufteilung der Implementierung das Entwicklerteam, das für die Implementierung des \glspl{model} zuständig ist, keine Kenntnis über die Struktur des \glspl{view-model} oder gar der \gls{view} haben muss und darüber hinaus könnten auch weitere \gls{observer} auf Benachrichtigungen des \glspl{model} registriert werden, beispielsweise, um weitere Aktionen nach Auftreten eines Events durchzuführen.

Neben diesen architektonischen Aspekten wurde hier das \gls{observer-pattern} für die Kopplung zwischen \gls{model} und \gls{view-model} gewählt, da bei Anforderung der Daten durch das \gls{view-model} noch nicht bekannt ist, wann diese Daten genau zurückgeliefert werden, da das \gls{cordova}-\gls{framework} nach Aufruf einer \gls{plugin}-\gls{api}-Methode\footnote{Beispielweise \lstinline|navigator.contacts.find()| zum Anfordern der Kontaktdaten aus dem Adressbuch} ausgeführt wird (\seeref{lst:find-contacts}).} diese erst vom Gerät laden muss und so das Zurückliefern der Daten per Rückgabewert zu einem \lstinline|null|-Wert führen kann, da bei Aufruf der Methode \lstinline|findContacts()| die Daten unter Umständen noch nicht verfügbar sind (\seeref{lst:find-contacts}).
% Auskommentiert, da nicht sicher, ob das wirklich der Grund bei Cordova.
%Dazu dient auch die Übergabe eines \lstinline|onSuccess|-\glspl{handler}, der nach Erfolgreicher Ausführung der \og \gls{api}-Methode ausgeführt wird. 
%%TODO Theoretische erläuterungen zu cordova in Theorie-Teil verschieben!


\chapter{Implementierung der Geräte-Schnittstelle}	\label{sec:explo}	%TODO Gliederung bzw. Name des Abschnitts? Erklärung der Architekur-Impl ist ja auch Umsetzung --> Evtl. nochmal Strippgen fragen.
%TODO Titel sowieso schwierig, weil kapitel ja schon "Praktische Umsetzung" heißt.

%\section{Ausgewählte Technologie} 
%%TODO Gehört das hier wirklich noch hin? In Theorie-Teil ist doch eigentlich schon klar, welche Technologie ausgewählt wurde. % --> VERMUTLICH DOCH. GEHÖT JA ZU EIGENEM ANTEIL, TECHNOLOGIEN AUSZUWÄHLEN.
%%TODO Evtl. einfach mit in folgenden Abschnitt verbacken, weil nicht mehr als eine Seite wird.	--> Zumal sowas wie obsever-pattern bzw. mvvm an cordova bzw. knockoout hängt.



%\section{Implementierung der Geräte-Schnittstelle}
% Beschreibung der konkreten Umsetzung, Implementierung der wesentlichen Features mithilfe der Technologien (Funktionsweise (Wie genau bewerkstelligt \gls{framework} die Plattformunabhängigkeit / Was steckt dahinter?))

		
\section{Zugriff auf die Kontaktverwaltung des Geräts} \label{sec:contacts}

\subsection{Funktionsweise}

Im Anwendungsfall \emph{Liste Teilen} der in \autoref{sec:bsp-app} beschriebenen Beispielanwendung \todo{Anwendungsfallbeschreibung einfügen.} soll die Anforderung erfüllt werden, aus der Anwendung heraus auf das native Adressbuch des Geräts zuzugreifen, um die bestehenden Kontakte zu laden und anzuzeigen, sodass diese vom Nutzer ausgewählt werden, an die Anwendung übergeben und als neues Listenmitglied in ein Listenobjekt eingetragen werden können.

Nachdem das \gls{cordova}-Plugin \emph{Contacts}, wie in \fullref{sec:cordova} beschrieben, zur Anwendung hinzugefügt wurde, lässt sich damit der Zugriff auf die native Kontaktverwaltung des jeweiligen Betriebssystems bewerkstelligen.
Dieses bietet beispielsweise die Möglichkeit, nach bestimmten Kontakten im Adressbuch zu suchen, neue Kontakte zu erstellen und dem Adressbuch hinzuzufügen, sowie bestehende Kontakte zu entfernen oder zu duplizieren \cite{Cordova_Plugin_Registry_Contacts}.

Um Kontakte im Adressbuch zu suchen, muss im Wesentlichen die Methode \lstinline|navigator.contacts.find(fields, onSuccess, onError, options)| ausgeführt werden, wobei \lstinline|fields| die zu durchsuchenden Datenfelder repräsentiert, \lstinline|onSuccess| die Funktion angibt, die bei erfolgreicher Ausführung der \lstinline|find|-Methode ausgeführt werden soll, \lstinline|onError| den \gls{errorhandler} bei Auftreten eines Fehlers beim Suchen der Kontakte und \lstinline|options| zusätzliche Optionen wie Suchfilter oder ein \lstinline|multiple|-\gls{flag}, das angibt, ob mehrere Kontakte zurückgegeben werden sollen (\seeref{lst:find-contacts}, \linename 26).
Die \lstinline|find|-Methode wird \gls{asynchron} ausgeführt, das heißt, dass der Aufrufer nicht wissen kann, wann das Ergebnis zurückgeliefert wird, also nicht als Rückgabewert zurückgegeben werden kann, sondern bei erfolgreicher Suche an den \og \lstinline|onSuccess|-\gls{handler} übergeben wird und dort weiter verarbeitet werden kann \cite{Cordova_Plugin_Registry_Contacts}.

Da in diesem Beispiel (\autoref{lst:find-contacts}) keine bestimmten, sondern \emph{alle} Kontakte angezeigt werden sollen, wird der \lstinline|find|-Methode kein spezieller \lstinline|filter| übergeben (\linename 23). 
Ebenso ist aus dem selben Grund hier keine Einschränkung der durchsuchten Felder nötig, sodass durch der \lstinline|fields|-Parameter den Wert \lstinline|"*"| hat, und so alle Felder des \lstinline|Contact|-Objekts durchsucht werden (\linename 25).
Bei erfolgreicher Ausführung der \lstinline|find|-Methode werden die zurückgegebenen Kontaktdaten als Parameter in Form eines \glspl{array}, das die entsprechenden JavaScript-Objekte vom Typ \lstinline|Contact| beinhaltet, an die \lstinline|onSuccess|-Methode übergeben und vom \gls{model} an dessen \gls{observer} (in diesem Fall das \gls{view-model}) versendet (\linename 13). 

Der Bezeichner \lstinline|events.FOUND_CONTACTS| stellt eine String-Konstante dar, die in einem globalen Konstanten-Objekt definiert wurde und den Typ des \glspl{event} identifiziert (\seeref{lst:app:consts.js}).

	\includehtml{praxis/find-contacts.js} { label=lst:find-contacts, caption={Verwendung des \emph{Contacts}-Plugins von \gls{cordova}.}}

Die in \autoref{lst:find-contacts} per \gls{observer-pattern} versendeten Daten werden in der entsprechenden \gls{handler}-Methode an die \lstinline|contacts|-Eigenschaft des \glspl{view-model} übergeben (\autoref{lst:ViewModel-Contacts}, \linenamepl 16\,-\,18), deren Elemente (also die Kontakt-Objekte) anschließend durch das Data-Binding in der Oberfläche angezeigt werden (\su).

	\includehtml{praxis/ViewModel-Contacts.js}{label=lst:ViewModel-Contacts, caption={Wesentlicher Ausschnitt des \glspl{view-model}.},}

Die Methode \lstinline|findContacts()|, die den Aufruf zum Laden der Kontakte an das \gls{model} delegiert, wird hier per Event-Binding an die Kontakt-Komponente der Oberfläche gebunden, sodass diese jedes mal aufgerufen wird, wenn die Kontaktliste auf- oder zugeklappt wird, um die Daten aus dem \gls{model} anzufordern (\seeref{lst:contacts-ui}, \linename 3).
Durch die Bindung der Eigenschaft \lstinline|contacts| in Form eines \emph{Observable Arrays} des \glspl{view-model} (\autoref{lst:ViewModel-Contacts}, \linename 6) an die \gls{listview} der Oberfläche werden in dieser Liste alle Kontakte des Adressbuchs angezeigt (\seeref{lst:contacts-ui}, \linename 7).

	\includehtml{praxis/contacts-ui.html}{label=lst:contacts-ui, caption={\gls{ui}-Komponente zur Darstellung der Kontaktliste und Auswahl einzelner Kontakte.},}
	
\doubleimage[contacts]{apps-overview}
	{apps-overview-android}{apps-overview-ios}
	{Die installierte App in der \gls{android}-\glspl{app}-Übersicht.}
	{Die installierte App in der \gls{ios}-\glspl{app}-Übersicht.}
	{Die installierte App in der App-Übersicht.}
	{Nach der Ausführung des \lstinline|cordova emulate|-Befehls wird die zu testende \gls{cordova}-\gls{app} in der Übersicht des Betriebssystems im jeweiligen Emulator angezeigt.}
	{Eigener Screenshot.}
	
\doubleimage[contacts]{contacts-app}
	{contacts-android}{contacts-ios}
	{\gls{android}-Adressbuch.}{\gls{ios}-Adressbuch.}
	{Natives Adressbuch mit Beispiel-Kontakten}
	{Anzeige des nativen Adressbuchs mit Beispiel-Kontakten.}
	{\ownScreenshot}
	
\doubleimage[contacts]{errands-members}
	{errands-members-expanded-android}{errands-members-expanded-ios}
	{Auswahl-Dialog unter \gls{android}.}{Auswahl-Dialog unter \gls{ios}.}
	{Kontakt-Auswahl in der Anwendung}
	{Kontakt-Auswahl-Dialog für das Hinzufügen von Kontakten aus dem Adressbuch. Die Anwendung lädt die Kontakte aus dem Adressbuch des Geräts in die Auswahl-Box der Anwendung (\seeref{fig:contacts-app}).}
	{\ownScreenshot}
	
\doubleimage[contacts]{errands-selected}
	{errands-members-selected-android}{errands-members-selected-2-ios}
	{Selektierte Kontakt-Einträge unter \gls{android}.}{Selektierte Kontakt-Einträge unter \gls{ios}.}
	{Übergabe der Kontakte an die Anwendung}
	{Übergabe der Kontakte an die Anwendung: Wird ein Kontakt ausgewählt, wird dieser dem \gls{obs}-\gls{array} \lstinline|contacts| des \glspl{view-model} (\seeref{lst:ViewModel-Contacts}) hinzugefügt und als \emph{ausgewählt} in der Oberfläche markiert.}
	{\ownScreenshot}
	
\subsection{Explorationsergebnisse}
Einige Unterschiede ergeben sich bei der Verwendung des \emph{Contacts}-\glspl{plugin} zwischen den verschiedenen Zielplattformen.
So können beispielsweise nicht alle Methoden der \gls{contacts-api} auf allen mobilen Plattformen gleichermaßen ausgeführt werden.
Die hier verwendete \lstinline|find()|-Methode bietet mit der Unterstützung für \gls{android}, \gls{blackberry-os}, \gls{ff-os}, \gls{ios}, \gls{win-phone} und \gls{win8} eine relativ  breite Kompatibilität für alle größeren gängigen und mobilen Betriebssysteme.
Allerdings auch werden einige Datentypen \emph{nicht} von allen Plattformen unterstützt, so zum Beispiel das \lstinline|ContactOrganization|-Objekt\footnote{\seefullpageref{sec:cordova-grundlegendes}.}, das lediglich bei der Entwicklung für \gls{android}, \gls{blackberry-os}, \gls{ff-os}, \gls{ios} und \gls{win-phone} zur Verfügung steht, damit aber immer noch alle großen Plattformen unterstützt \cite{Cordova_Plugin_Registry_Contacts}.

Doch auch bei den unterstützten Plattformen sind einige Besonderheiten zu beachten, wenn es um die Verwendung einzelner Attribute der verschiedenen Objekttypen geht.
So ist beispielsweise das Feld \lstinline|displayName| des \lstinline|Contact|-Objekts unter \gls{ios} nicht verfügbar, sodass in diesem Fall auf das \lstinline|name|- oder \lstinline|nickname|-Feld zurückgegriffen werden muss.
Ähnliches gilt auch für weitere Objekte oder deren Methoden und Felder, die unter bestimmten Plattformen nicht oder nur teilweise unter Berücksichtigung bestimmter Besonderheiten funktionieren \cite{Cordova_Plugin_Registry_Contacts}.

So wird beispielsweise \lstinline|find|-Methode grundsätzlich mit \gls{android}, \gls{blackberry-os}, \gls{ff-os}, \gls{ios}, \gls{win-phone} und \gls{win8} von den wichtigsten mobilen \glspl{plattform} unterstützt, doch bei letzterer besteht die Einschränkung, dass aus der hybriden \gls{app} heraus nicht ohne weiteres auf die Kontaktdaten zugegriffen werden kann, wie es bei den anderen \glspl{plattform} der Fall ist (\so), sondern eine Nutzerinteraktion nötig ist, um Kontakte aus dem Adressbuch auszuwählen und weiter zu verarbeiten, sodass bei Anfrage von Kontaktdaten die \gls{app} für das native \gls{win8}-Adressbuch geöffnet wird und der Nutzer die gewünschten Kontakte selbst von Hand auswählen muss.
Darüber hinaus bieten \gls{win8}-Kontakte lediglich einen Lesezugriff, sodass hier aus der Kontaktdatenbank geladene Objekte nicht verändert, gelöscht oder dupliziert werden können \cite{Cordova_Plugin_Registry_Contacts}.

Eine Kategorisierung von Kontakten über das \lstinline|cagegories|-Attribut wird bei \gls{ff-os} sowie \gls{ios} nicht unterstützt, sodass beim Versuch, diesen Wert anzufragen, \lstinline|null| zurückgegeben wird.
In Bezug auf die Unterstützung des \lstinline|Contact|-Objekts ergeben sich die meisten Einschränkungen für die Plattform \gls{win-phone}.
Hier finden sich in der \gls{contacts-api}-Dokumentation beispielsweise Informationen über ein teilweise leicht inkonsistentes Verhalten beim Erstellen bzw. Suchen von Kontakten.
So unterscheidet sich beispielsweise der Wert des \lstinline|displayName|-Attributs, das bei Erstellung eines \lstinline|Contact|-Objekts angegeben wird von dem, das bei der Suche zurückgeliefert wird.
Ebenso können bei der Erstellung eines \lstinline|Contact|-Objekts mehrere \glspl{url} angegeben werden, während bei den Objekten des Suchergebnisses nach Ausführung der \lstinline|find|-Methode lediglich \emph{eine} verfügbar ist.

Einige Listenfelder des \lstinline|Contact|-Objekts besitzen ein Attribut mit dem Namen \lstinline|pref|, dem ein boolescher Wert zugewiesen kann, der angibt, ob das jeweilige Objekt innerhalb einer Liste\footnote{So beispielsweise bei den Feldern \lstinline|emails|, \lstinline|phoneNumbers| oder \lstinline|addresses|, denen jeweils mehrere E-Mail-Adressen, Telefonnummern bzw. Adressen zugewiesen werden können.} das vom Nutzer präferierte darstellt.
Dieses \lstinline|pref|-Attribut wird ebenfalls unter einigen Plattformen nicht unterstützt, so \zB für \lstinline|phoneNumbers| und \lstinline|emails| unter \gls{win-phone} sowie beim \lstinline|addresses|-Feld unter \gls{android}\,2.X, \gls{blackberry-os}, \gls{ios} und \gls{win8}.
Die \lstinline|Contact|-Felder \mbox{\lstinline|note|,} \mbox{\lstinline|ims|,} \lstinline|birthdays| und \lstinline|categories| werden für \gls{win-phone} gar nicht unterstützt.

Das \og \lstinline|Contact|-Feld \lstinline|name| hat den Datentyp \lstinline|ContactName| besteht und besteht aus den weiteren \gls{string}-Attributen \mbox{\lstinline|formatted|,} \mbox{\lstinline|familyName|,} \mbox{\lstinline|code|,} \mbox{\lstinline|middelName|,} \lstinline|honorificPrefix| und \lstinline|code|.
Grundlegend wird dieses Objekt zwar von allen elementaren Plattformen unterstützt, doch auch hier gibt es einige Einschränkungen.
Das \lstinline|formatted|-Attribut wird unter \gls{android}, \gls{blackberry-os}, \gls{ff-os} und \gls{ios} nur teilweise unterstützt und bietet für \gls{android}, \gls{ios} sowie \gls{ff-os} lediglich einen Lesezugriff.
Unter \gls{win8} stellt dieses das einzige Attribut des \lstinline|ContactName|-Objekts dar, alle anderen werden nicht unterstützt.

Während bei der nativen App-Entwicklung für \gls{ios} oder \gls{android} \gls{ui}-Kom\-po\-nen\-ten für die Arbeit mit Kontakten bereitstehen, liefert die \gls{contacts-api} hier lediglich Mechanismen für den Zugriff auf die Kontaktdaten, jedoch nicht die entsprechenden UI-Komponenten, da diese vom jeweiligen verwendeten \gls{gui}-Toolkit abhängen.
Die hier verwendete Oberflächen-Bibliothek \gls{jqm} beinhaltet lediglich allgemeine \glspl{widget} wie Listen, Buttons, Tabellen etc., sodass die Erstellung einer \gls{ui}-Komponente für die Auswahl von Kontakten dem Entwickler überlassen bleibt.

In Verbindung mit der Data-Binding-Bibliothek \gls{ko} kann eine solche Komponente jedoch relativ einfach erstellt werden, indem die Felder in der Oberfläche an Eigenschaften des \glspl{view-model} gebunden werden, welches durch Benachrichtigungen des Models, das den Zugriff auf die native Ebene des Betriebssystems abwickelt, die Daten der Anwendung und des Geräts anzeigen kann (\seeref{sec:ko}).

Grundsätzlich bietet die \gls{contacts-api} trotz einiger Einschränkungen (\so) ein nützliches Werkzeug mit einem relativ breiten Funktionsumfang für den grundlegenden Zugriff auf die Kontaktverwaltung der meisten großen mobilen Betriebssysteme.
Der für dieses Feature definierte Anwendungsfall konnte mit den Mitteln der \gls{cordova}-\gls{api} und weiteren Technologien der Webentwicklung wie \gls{ko} oder \gls{jqm} gut für die hier verwendeten Plattformen \gls{ios} und \gls{android} umgesetzt werden.
Trotz des grundsätzlich plattformunabhängigen Ansatzes sollte allerdings bei der Entwicklung mithilfe dieser \gls{api} die Unterstützung der verwendeten Features und Attribute und deren Besonderheiten für die angestrebten Zielplattformen in der \gls{contacts-api}-Dokumentation überprüft werden.
Somit ist eine Kenntnis über die angestrebten Zielplattformen für die Verwendung eines solchen \glspl{plugin} beinahe unabdingbar und die Entwicklung in gewisser Weise wieder ein Stück weit abhängiger von den verwendeten Plattformen. %TODO Den Satz evtl. auch ins Fazit!


%			Explorationsergebnisse
%			Grenzen und Möglichkeiten bei der Umsetzung (Nach jeder Feature-Beschreibung)
%				Aha-Erlebnisse
%				Konkrete Quellcode-Beispiele
%				Ecken und Kanten, Spitzfindigkeiten zeigen 
%				Eigenschaften, Was fällt auf ? Am Beispiel

\chapter{Fazit} % Zusammenfassung der Erfahrung Umsetzung
%		Benutzung (Technik, Methodik, Entwicklerfreundlichkeit, Kompatibilität mit anderen Systemen / Software)
%		Bewertung
%		Vor-/Nachteile (zueinander / gegenüber nativer App-Entw.), Risiken, Chancen
%TODO In \cite{Apache_Cordova_Contribute} werden noch einige Plattformen mehr aufgelistet. (wohl je nach cordova-version) -> evlt. hier auch noch erwähnen und/oder auflisten.

