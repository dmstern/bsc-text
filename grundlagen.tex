\part{Theoretische Grundlagen}
%1. Theoretische Grundlagen → als Grundlage für Implementierung
% Was muss der Leser wissen, um die Realisierung zu verstehen? 
%1. Konkreter, technologischer: Worum geht es bei Plattformunabhängigkeit, wie ist zu erreichen? → verschiedene grundsätzliche Konzepte
%2. Übersicht / Eigenschaften & Einordnung der vorgestellten L\"osungen
%3. Verwendete Technologien → wie macht das phonegap?
%1. Knockout, jquerymobile, etc.

\chapter{Apps für mobile Geräte}

\section{Mobile (native) Apps} \label{sec:native}
Unter mobilen \glspl{app} versteht man im Allgemeinen Anwendungssoftware für Tablet-Computer oder Smartphones. 
Im Laufe der letzten Jahre haben sich auf dem Markt für Mobilgeräte durch viele konkurrierende Gerätehersteller eine Vielzahl von Smartphone- und Tablet-Betriebssystemen herausgebildet.
Im Entwicklungsbereich wird in dem Zusammenhang auch von \glspl{plattform} gesprochen.

Zu den \glspl{plattform} mit dem höchsten Marktanteil zählen \glspl{google} Betriebssystem \gls{android}, \gls{ios} von \gls{apple}, \gls{win-phone} und \gls{blackberry-os} des gleichnamigen Smartphone-Herstellers \gls{blackberry-inc} \cite{platforms-marketshare}.
% Nativ-Entwicklung für die jeweiligen Plattformen: \gls{android} / iOS
Die \gls{app}-Entwicklung für diese mobilen Betriebssysteme erfolgt mehr oder weniger ähnlich und soll im Folgenden, um auf die beiden größten Vertreter einzugehen, anhand von \gls{android} beziehungsweise \gls{ios} näher beschrieben werden.

%	-> \gls{sdk}s verwalten
Grundsätzlich müssen auf der \gls{ide} die entsprechenden \glspl{sdk} der \gls{plattform}, für die entwickelt wird, installiert sein. 
Diese enthalten Softwarekomponenten, die zur Entwicklung der \gls{app} notwendig sind, beispielsweise Klassen, die es einem erlauben, auf native Funktionalitäten des Betriebssystems wie zum Beispiel das Adressbuch, den Benachrichtigungsmechanismus oder auch auf Hardwarekomponenten wie die Kamera, den Bewegungssensor oder das \gls{gps}-Modul zuzugreifen sowie die entsprechenden plattformspezifischen Oberflächenkomponenten des jeweiligen \gls{gui}-Toolkits zu nutzen.

%	-> Code schreiben für die jeweilige Plattform
% Allgemein / \gls{android}
Als Programmiersprache für die \gls{android}-\gls{app}-Entwicklung wird \gls{java} verwendet. Das heißt, als Voraussetzung für die Entwicklung von \gls{android}-\glspl{app} ist lediglich eine geeignete \gls{ide} wie \gls{eclipse}, \gls{netbeans} oder \gls{intellij} sowie eine Installation des \gls{java}- und des \gls{android}-\gls{sdk} nötig. 
\todo{wie sieht es mit dem deployment, also der Auslieferung in appstores etc. aus?}
Seit 2013 bietet Google darüber hinaus die auf \gls{intellij} basierende und eigens für die \gls{android}-Entwicklung angepasste \gls{ide} \gls{android-studio} an \cite{android-studio}, die bereits alle notwendigen Toolkits enthält. 
Nachdem der Code geschrieben ist, kann er kompiliert und zu einem lauffähigen Programm \emph{gebaut} (engl. \enquote{build}) %TODO ins Glossar, allerdings eigentlich mit Beugung und so
 werden (\seeref{fig:hybrid-apps-schaubild}). Anschließend kann die \gls{app} in dem für die Zielplattform vorgesehenen Dateiformat ausgeliefert und auf dem Zielgerät installiert werden.

% iOS: 
Auch der Software- und Computer-Hersteller Apple bietet mit \gls{xcode} eine firmeneigene \gls{ide} zur \gls{app}-Entwicklung für sein mobiles Betriebssystem \gls{ios} an. 
Anders als Google geht der iPhone-Hersteller hier allerdings etwas restriktiver vor. 
So läuft die \gls{ide} \gls{xcode}, die man für die native \gls{ios}-Entwicklung benötigt, nur unter dem hauseigenen Betriebssystem \gls{osx} und das wiederum nur auf den firmeneigenen Mac-Rechnern \cite{Cordova_Documentation_iOS_Platform_Guide}.
Darüber hinaus ist für \gls{ios}-Entwickler die Teilnahme am \gls{ios-dev-prog} erforderlich, um \glspl{app} für \gls{apple}-Geräte auszuliefern und auf Geräten installieren zu können, wofür der Konzern einen jährlichen Mitgliedsbeitrag von 99\,\$ im Jahr verlangt \cite{iOS_Developer_Program}.
So sichert sich Apple, nicht nur durch die kostenpflichtige Mitgliedschaft im \gls{ios-dev-prog}, sondern allein schon durch deren exklusive Platformunterstützung ihres eigenen Mobilbetriebssystems, auch mit jedem Entwickler einen neuen Kunden.\footnote{Diese Restriktion fällt allerdings auch in der unten beschriebenen plattformunabhängigen App-Entwicklung nicht unbedingt weg (\seeref{sec:hybrid-dev}).} \todo{darf man so was hier anmerken, oder lieber weg?}

Ansonsten verläuft der Entwicklungsprozess bei der \gls{ios}-Entwicklung im Prinzip ähnlich zur \gls{android}-Entwicklung (\seeref{fig:hybrid-apps-schaubild}).
Als Programmiersprache wird \gls{obj-c} verwendet, einer um objektorientierte Elemente erweiterte Variante der Programmiersprache \gls{c}.

Möchte ein Auftraggeber einer Software also statt seinen Kunden nur eine \gls{app} für ein Betriebssystem anzubieten, einen größeren Nutzerkreis erschließen, muss die zu entwickelnde \gls{app} für jede Zielplattform neu programmiert, getestet und gebaut werden, da jede mobile \gls{plattform} ihre eigenen Toolkits, Bibliotheken und Programmiersprachen verwendet, was die native \gls{app}-Entwicklung für potenzielle Auftraggeber zu einem sehr kostenaufwändigen Projekt werden lassen kann.
Andererseits bietet die native \gls{app}-Entwicklung vollständige Unterstützung der betriebssystemeigenen Funktionalitäten wie den Zugriff auf Kamera, Adressbuch, Bewegungssensoren etc. der jeweiligen \gls{plattform}, sodass ein Softwareprojekt mit solchen besonders hardware- oder betriebssystemnahen Anforderungen die Entwicklung einer nativen (plattformspezifischen) \gls{app} notwendig erscheinen lassen kann.\footnote{Mehr dazu in \autoref{sec:hybrid-dev}}

\section{Web-Anwendungen}\label{sec:web-app}

% Zuerst gab es Websites, dann dynamische Websites
Eine \gls{web-app} ist eine Anwendungssoftware, die auf einem Web-Server läuft und auf die der Nutzer mittels eines Browsers zugreifen kann; also eine dynamische Website, wie man sie auch schon vor dem Aufkommen von Smartphones und modernen Tablets kannte. 

Die Grundlage für die Entwicklung von Internetseiten bildet der langjährige Standard \gls{html}, mit dem deren Aussehen, Inhalt und Struktur textuell beschrieben werden kann. 
In Kombination mit \gls{css} für die modulare Gestaltung einer Website sowie \gls{js}, einer Skriptsprache zur \gls{dom}-Manipulation, bietet die \gls{html}-Spezifikation in ihrer neusten Version \textit{(\gls{html5})} im Grunde alles, was für die Entwicklung einer modernen grafischen Benutzerschnittstelle notwendig ist. 
Die Fachlogik liegt, neben den Oberflächen-Komponenten in Form von \mbox{\gls{html}-,} \gls{css}- und Javascript-Dokumenten, auf einem Webserver und verarbeitet und reagiert auf Anfragen des Clients.\footnote{Die Rolle des Clients übernimmt hier also der Browser.}
Als Server-Technologie ist ein breites Spektrum an Programmiersprachen und Umgebungen einsetzbar.\footnote{Einige sind beispielsweise \gls*{php}, \gls*{java}, \gls*{asp} u.\,v.\,a.\,m.}

Somit bietet die Entwicklung einer \gls{web-app} (abgesehen von einigen Browser-spezifischen Eigenheiten) bereits eine gewisse Plattformunabhängigkeit, da jedes moderne Betriebssystem über einen Webbrowser verfügt. 
Zwar müssen Entwickler in bestimmten Details bei der Erstellung des Codes auf die teilweise unterschiedliche Unterstützung (beispielsweise von \gls{html}-Elementen) \todo{genauer?} durch die verschiedenen Browser achten, aber darüber hinaus wird der Entwicklungsaufwand für eine \gls{web-app} nicht von der Anzahl der Zielplattformen bestimmt, da von Client-Seite aus verschiedene Browser durch die Verbreitung und Beachtung von Web-Standards weitgehend einheitliche \gls{html}-Dokumente lesen und interpretieren können und das Back\-end nicht auf Clients mit unterschiedlichen \glspl{plattform}, sondern auf Webservern liegt, deren \gls{plattform} bei der Entwicklung entweder schon bekannt oder nicht relevant ist.\footnote{Beispielsweise weil auch die Fachlogik plattformunabhängig mit \gls*{php} oder \gls*{java} realisiert wurde.}

% Dann für sämtliche Internet-Dienste auch noch eine \gls{app}
Obwohl es, durch damals eher im Business-Bereich verortete Internet-Handys und Palmtops, auch vor den heute üblichen mobilen Touch-Geräten bereits mobile Internetseiten gab, die speziell für die Darstellung auf kleinen Displays ausgerichtet waren, boten mit der massenhaften Verbreitung von mobilen, internetfähigen Geräten und deren (im Folgenden erläuterten) stark anwendungsorientierten Bedien-Konzepten viele herkömmliche Internet-Dienste nun auch zusätzlich eine native \gls{app} für verschiedene mobile \glspl{plattform} an.
So sind beispielsweise auch E-Mail-Dienste wie \gls{gmx}, \gls{web-de} oder \gls{gmail} seit der Verbreitung von Smartphones und Tablets auch in Form einer eigenen \gls{app} für \gls{android} und \gls{ios} vertreten, sodass der Nutzer, statt, wie von der Desktop-Computer-Nutzung gewohnt, einen anbieterunabhängigen Mail-Client zu konfigurieren, über den er seine E-Mails abruft, unter Umständen gleich die jeweilige \gls{app} des E-Mail-Anbieters startet \cite{gmx, web.de, gmail}.
Das heißt, der Nutzer folgt einem geänderten Bedienungsmuster seines Mobilgeräts gegenüber der herkömmlichen Computer-Nutzung: um zu einem bestimmten Ergebnis zu gelangen (beispielsweise \emph{Nachrichten lesen}) also die Frage zu beantworten, \emph{wie} er dahin gelangt (Einen Browser öffnen und zur gewünschten Seite navigieren: www.tagesschau.de), ist es für Anwender heutiger Mobilsysteme naheliegend, gleich die passende \gls{app} zu starten (Hier \zB die Tagesschau-\gls{app}).

% Gründe für App statt Web-Anwendung
Dafür gibt es verschiedene mögliche Gründe. Zum Einen muss im Gegensatz zu einer Website bei der mobilen \gls{app} nicht die komplette Oberfläche\footnote{\gls{html}-, \gls{css}- und \gls{js}-Dokumente sowie Grafiken} übertragen werden, sondern lediglich die Nutzdaten,\footnote{Also beispielsweise, um beim obigen Beispiel zu bleiben, die Nachrichten in Textform.} was dem Nutzer ein höheres Maß an Performanz einbringt.
Zum Anderen können trotz Vollbildmodus in bestimmten Fällen \gls{gui}-Elemente des Webbrowsers bei der Benutzung einer Web-Anwendung störend sein, so ist beispielsweise die Adresszeile am Rand nicht unbedingt erwünscht, wenn der Nutzer statt im Internet zu surfen dort eigentlich eine bestimmte Anwendung nutzen möchte. 
Ein anderes Beispiel für ein eventuell unerwünschtes Verhalten der Benutzerschnittstelle ist das der \emph{Menü}-Taste bei \gls{android}-Geräten, die im Falle der Nutzung einer Web-Anwendung über den Browser nicht den Kontext der eigentlich benutzten Anwendung anzeigt,\footnote{hier also der Website} sondern lediglich den des Browsers.

In bestimmten Fällen kann eine nützliche Funktion einer \gls{app} die Offline-Nutzung sein, wenn beispielsweise durch die abgedeckten Anwendungsfälle keine Verbindung oder Synchronisation mit einem Server nötig ist. Beispiele hierfür könnten, um nur einige zu nennen, ein Taschenrechner, kleine Spiele, oder eine Bildverarbeitungs-\gls{app} sein. 
Für diese Offline-Nutzung einer \gls{app} zeichnet die Web-Anwendung ein geteiltes Bild: Zwar wurden in den letzten Jahren mehrere Methoden entwickelt, eine Web-Anwendung auch offline nutzen zu können, doch durch ihre Ausrichtung auf die Nutzung via Internet stellt die Implementierung dieser Funktionalität für Entwickler einen Zusatzaufwand dar. 

Einige Möglichkeiten, eine Web-Anwendung ohne Internetverbindung nutzbar zu machen, sind beispielsweise die aus der \gls{html5}-Spezifikation hervorgehenden Technologien \gls{webstorage}, ein Mechanismus zum lokalen Speichern von größeren Datenmengen in Form von Schlüssel-Wert-Paaren \cite{w3c_webstorage} sowie \gls{websql} bzw. \gls{indexed-db}, beides auf Web-Anwendungen optimierte Datenbanken-Spezifikationen, die vom \gls{w3c} herausgegeben werden \cite{w3c_websql, w3c_indexedDB}.
Allerdings bestehen auch bei diesen Mechanismen teilweise Einschränkungen durch die Browservielfalt beziehungsweise deren Versionen. So wird \gls{indexed-db} beispielsweise nicht von \gls{safari} oder \gls{ios} unterstützt, \gls{chrome} muss für die Nutzung mindestens in Version 23 oder höher vorliegen, \gls{firefox} in 10 oder höher. 
Auch bei \gls{websql} zeichnet sich ein ähnlich diffuses Bild ab: Während \gls{chrome} die Technologie ab der Version 4 und \gls{ios} ab Version 3.2 unterstützt, ist für Nutzer der Browser \gls{firefox} und \gls{ie} die Technik gar nicht verfügbar.
Lediglich \gls{webstorage} wird weitgehend von allen gängigen Browsern unterstützt \cite{html5-rocks_offline}.
Weiterhin wird die Offline-Funktionalität gegenüber der nativen \gls{app} dadurch eingeschränkt, dass der Nutzer diese ohne weiteres Zutun des Entwicklers nur dann nutzen kann, wenn die entsprechende Internet-Seite im Offline-Zustand des Geräts bereits im Browser geöffnet ist, da diese nicht lokal auf dem Gerät, sondern auf einem Webserver gespeichert ist.
Für vollständigen Offline-Zugriff müsste der Entwickler die komplette Website so paketieren, dass der Nutzer sie -- wie eine native App -- von seinem Gerät aus starten und nutzen kann.\footnote{\seeref{sec:hybrid-app} und \ref{sec:hybrid-dev}.}

Allgemein kann man sagen, dass der Zugriff auf native Funktionalitäten des Geräts respektive des Betriebssystems nicht oder nur gering unterstützt wird, sodass der geringere Entwicklungsaufwand einer solchen \gls{web-app} (\seename~ \autoref{fig:hybrid-apps-schaubild}) unter Umständen zu Lasten des Funktionsumfangs und der Usability der Anwendung geht.
\todo{recherchieren: wird was unterstützt? gibt es Möglichkeiten, per Javascript etc.? Was wird \enquote{gering} unterstützt? sollte man das noch weiter ausführen? Touch-Gesten etc.?}

\section{Hybride Apps} \label{sec:hybrid-app}

Die \gls{hybrid-app} verbindet Eigenschaften der Nutzung einer nativen \gls{app} mit den Vorteilen der Web-Entwicklung mithilfe von Web-Technologien und entsprechenden \glspl{framework} und löst damit beispielsweise das Problem der mangelnden Offline-Fähigkeit einer \gls{web-app} sowie deren geringe Unterstützung von plattformspezifischen oder hardware-nahen Funktionalitäten. 
Da jedes moderne mobile Betriebssystem für Entwickler auch die Möglichkeit bietet, eine \gls{web-view} in die zu entwickelnde App einzubinden, also eine \gls{gui}-Komponente, in die \gls{html}-Inhalte hinein geladen werden können, liegt der Ansatz für hybride Apps auf der Hand: Auf Entwicklungsebene wird die Anwendung als \gls{web-app} entwickelt, gleichzeitig mithilfe von entsprechenden \glspl{api} und \glspl{framework} zur Anbindung an die native Ebene der Zielplattform in eine App für die jeweiligen \glspl{plattform} integriert, sodass auf Benutzerseite die Nutzung einer Web-Anwendung, die in puncto Funktionsumfang, Usability und Look-And-Feel einer nativen mobilen App sehr nahe kommt, möglich wird.

Dieses Vorgehen bietet unter anderem für Web-Entwickler den Vorteil, ihre bisherigen Programmierkenntnisse im Web-Bereich im Wesentlichen auch für die Entwicklung von hybriden \glspl{app} nutzen zu können. 
So wird in der Regel der grundlegende Teil des Codes für das \gls{frontend}, wie bei der Web-Entwicklung, mit \gls{html} in Kombination mit \gls{css} und \gls{js} geschrieben und getestet. 
Da allerdings auf dem mobilen Gerät für das Backend, also die Verarbeitungsinstanzen, nicht, wie bei einer herkömmlichen Web-Anwendung, ein Server mit einer entsprechenden Server-Technologie wie \gls{php} oder \gls{asp} läuft, wird auch dieser Teil der App bei der hybriden Entwicklung meist mit \gls{js} bewerkstelligt. 
\todo{Recherchieren! Kann man Perl oder Python oder so auf einem \gls{android} laufen lassen?}
Anschließend muss die Anwendung für die verschiedenen Zielplattformen gebaut werden, um in das jeweilige Container-Format für Apps der verschiedenen \glspl{plattform} eingebunden werden zu können und den Zugriff auf die plattformspezifischen Toolkits durch die Cross-Platform-\glspl{api} zu ermöglichen (\autoref{fig:hybrid-apps-schaubild}).
Hierfür kann es erforderlich sein, dass auf der Entwicklungsplattform die jeweiligen \glspl{sdk} installiert sind, was gegenüber der Web-Entwicklung einen administrativen Mehraufwand darstellt.
Eine andere Variante ist die Auslagerung des Bauprozesses auf einen externen Build-Server, beispielsweise mithilfe eines externen Web-Service eines Drittanbieters, was den Vorteil hat, die \glspl{sdk} für die Zielplattformen nicht auf jedem Entwicklungsrechner verwalten zu müssen. 
Allerdings hat der Entwickler durch die Herausgabe des Codes an einen solchen Dienstleister nicht mehr die vollständige Kontrolle über den Code, sodass die Variante der Auslagerung des Build-Prozesses gerade für Closed-Source-Projekte unter Umständen nicht in Frage kommt. 
Des Weiteren kann der Betreiber des Build-Services unter Umständen Restriktionen bezüglich der Plattformunterstützung erteilen, wodurch eventuell eine geringere Anzahl von Zielplattformen unterstützt wird, als von Entwicklerseite gewünscht oder erfordert.\footnote{Beispielsweise unterstützt \gls{pg-build} in der neusten Version 3 nur noch die drei großen Mobilplattformen \gls{android}, \gls{ios}, und \gls{win-phone}.}

\image{hybrid-apps-schaubild}
	{width=\fullimagesize}
	{Schaubild Hybrid Apps}
		{Entwicklungsstufen der verschiedenen Arten von Apps. Während bei der nativen App der gesamte Entwicklungszyklus einmal pro \gls{plattform} durchlaufen werden muss, verringert sich der Aufwand für die \gls{web-app} erheblich. Bei der \gls{hybrid-app} muss die Anwendung zwar einmal für jede \gls{plattform} gebaut und ausgeliefert werden, um die Schnittstellen für die nativen \glspl{plattform} zu implementieren, aber der hauptsächliche Entwicklungsaufwand des Programmierens und Testens fällt aufgrund des generischen Charakters nur einmal an.}
	{Eigene Grafik.}

\chapter{Plattformunabhängige App-Entwicklung}

\section[Überblick: Lösungen und Ansätze]{Überblick: Lösungen und Ansätze für die platt\-form\-un\-ab\-hängige App-Entwicklung} \label{overview}

%TODO Schöneren Einleitungssatz finden.
Es gibt sehr viele Frameworks und Lösungen zum Erreichen einer plattformunabhängigen App-Entwicklung. Die Unterschiedlichen Ansätze begründen sich in unterschiedlichen Anforderungen an die zu entwickelnde App, unterschiedliche vorhandene Ressourcen und Infrastruktur der Entwickler und App-Betreiber sowie dem Ziel, bestehendes Know-How der Entwickler einbringen zu können.
Im Folgenden soll ein Überblick über verschiedene Ansätze gegeben und konkrete Beispiele genannt werden. Dabei wird die im vorherigen Abschnitt vorgenommenen Gruppierung in native Apps, \glspl{web-app} und hybride-Apps beibehalten.

Wie in \autoref{sec:web-app} erwähnt, sind \glspl{web-app} durch die Client-Server-Konzeption, in Verbindung mit Web-Standards, die jeder moderne Browser unterstützt, in gewisser Weise per se plattformunabhängig. Die fehlende Offline-Nutzbarkeit, der eingeschränkte Zugriff auf Hardwarekomponenten wie Gerätetasten, Kamera, GPS-Modul, Mikrofon,\footnote{Diese ist teilweise im noch nicht von allen Browsern voll umgesetzten \gls{html5}-Standard begründet.} der fehlende Zugriff auf Systemdaten wie das Adressbuch, Speicherkarten und das nicht native Systemdesign sind dabei offenkundige Nachteile der \glspl{web-app}, die sie für manche Anwendungsgebiete nicht in Frage kommen lassen.

Wie in \autoref{sec:hybrid-app} beschrieben, stellen Hybrid-Apps einen naheliegenden Ansatz zur plattformunabhängigen App-Entwicklung dar. Durch den Einsatz von Standard-Web-Technologien wie \gls{html}, CSS und \gls{js} in Verbindung mit einer in einer nativen Container-App erzeugten \gls{web-view}, lassen sich schnell viele Plattformen erreichen. Hierzu gibt es Frameworks, die die nativen Container-Apps erstellen und zusätzlich \glspl{api} für Hardware-Zugriffe und Geräte- und Systemfunktionen, die nicht durch \gls{html} abgedeckt werden, bereit stellen. Ein häufig genutztes Beispiel hierfür ist das in \autoref{sec:cordova} beschriebene \gls{phonegap}\,/\,\gls{cordova}.

Eine Problematik, die sich bei allen Ansätzen zur plattformunabhängigen App-Entwicklung stellt, sind die in \autoref{sec:native} erwähnten unterschiedlichen Designs und Designrichtlinien sowie unterschiedlichen Bedienkonzepte. Soll die hybride App also dem \gls{look-and-feel} einer nativen sehr nahekommen, so muss zu einem gewissen Grat die Benutzeroberfläche für jede Plattform bspw. mithilfe von Stylesheets separat angepasst werden.

Durch den konsequenten Ansatz von \gls{html}, Design-Elemente über Stylesheets auszulagern, hat der Entwickler hier die Möglichkeit, seine Benutzeroberfläche für jedes System über das laden unterschiedlicher Stylesheets anzupassen.
Hierzu bietet beispielsweise \gls{intel} mit seinem \gls{app-framework} eine \gls{js}-Oberflächenbibliothek, der entsprechende Stylesheets für jede große Plattform zugrunde liegen. So wird diese Arbeit dem Entwickler abgenommen und die App soll sich so gut in das native Design einfügen.
Es sei allerdings erwähnt, dass weiterhin keine GUI-Elemente nativ gerendert werden, sondern lediglich versucht wird, durch das Anpassen von Farbe, Form und Schrift einen nativen Look zu erzeugen.

Wie in \autoref{sec:native} beschrieben, kommen für das Entwickeln nativer Apps für jede Plattform andere Programmiersprachen, \glspl{sdk} und GUI-Toolkits zum Einsatz. Um eine native App plattformunabhängig entwickeln zu können, sind daher Schnittstellen erforderlich, mit denen auf die Funktionen der nativen \glspl{sdk} zugegriffen werden und eine native App kompiliert werden kann. Im Gegensatz zu hybriden Apps sollen also für die Benutzeroberfläche native Elemente verwendet werden, und keine eigene \gls{html} Oberfläche geschaffen werden. Für die Umsetzung der Funktionslogik gibt es, grob gesprochen, zwei Möglichkeiten. Entweder wird ausgehend von einem Code nativer Bitcode für die jeweilige Plattform kompiliert, sogenanntes \gls{cross-compiling}, oder eine Skriptsprache in einer integrierten Runtime-Environment interpretiert bzw. in einer virtuellen Maschine ausgeführt.

Ein Beispiel eines Frameworks, bei dem der gemeinsame Code in einer integrierten Runtime-Environment ausgeführt wird, ist \gls{titanium} der Firma \gls{appcelerator}. Programmiert wird in der  \gls{titanium}-\gls{sdk} komplett mit \gls{js}. Es wird allerdings nicht, wie bei hybriden Apps, eine \gls{web-view} mit einer Benutzeroberfläche in \gls{html5} erstellt, sondern der \gls{js} Code wird zur Laufzeit in nativen Code übersetzt und dieser ausgeführt. Mit dem \gls{mvc}-\gls{framework} \gls{alloy} steht dabei eine Benutzerschnittstellenabstraktion zur Verfügung, in der die Benutzeroberfläche in \gls{js} geschrieben werden kann, und zur Laufzeit die nativen Methoden der jeweiligen Plattform aufgerufen werden.

Ein \gls{cross-compiling} Beispiel ist das von \gls{xamarin} gesponserte Projekt \gls{mono}. \gls{mono} ist eine \gls{opensource}-Cross-Plattform-Implementierung der Programmiersprache \gls{c-sharp}. Mit den \gls{mono} nutzenden \glspl{sdk} \gls{xamarin-ios} (\gls{monotouch}) und \gls{xamarin-android} können so native \glspl{app} für \gls{ios} und \gls{android} gebaut werden. Für \gls{win-phone} wird standardmäßig in \gls{c-sharp} programmiert, so dass sich viele Bestandteile des Codes für alle drei Plattformen nutzen lassen.
\gls{xamarin} bildet so ein Komplettpaket, dass einen gemeinsamen Code für die Funktionslogik, sowie durch eine entsprechende \gls{api}, für die Benutzeroberfläche ermöglicht. Dabei wird durch den Kompiliervorgang auf die jeweiligen nativen Benutzeroberflächenelemente zurückgegriffen.

Im Bereich \gls{cross-compiling} gibt es etwas allgemeiner Programmiersprachen, die sich in ausführbare Dateien vieler Plattformen, sowie andere Programmiersprachen übersetzten lassen. Ein Beispiel hierfür ist die \gls{opensource}-Multiplattform-Programmiersprache Haxe, deren Code sich in \gls{js} .js-Dateien, \glspl{flash} .swf-Dateien, \gls{nekovm}-\gls{bytecode}, \gls{php}-Dateien, \gls{cpp}, \gls{c-sharp} und \gls{java}-Dateien übersetzten lässt. Zusammen mit den Bibliotheken \gls{lime} und \gls{openfl} kann auf die gesamte \gls{flash}-\gls{api} zugegriffen, und durch integrierte Unterstützung für \gls{swf}-Dateien die Möglichkeit der Nutzung der \gls{flash-editing-environment} für alle gängigen Plattformen ermöglicht werden. Das Projekt richtet sich hauptsächlich an Spieleentwickler, die so die relativ einfach zu erstellenden \gls{flash}-Spiele auf alle Plattformen bringen können.

Ist bereits eine bestehende native \gls{app} für eine Plattform vorhanden, die für andere Plattformen verfügbar gemacht werden soll, liegt der Ansatz nahe, zu versuchen, den bestehenden Quellcode für eine andere Plattform zu kompilieren. Ein solches Projekt ist \gls{xmlvm}, was durch eine Reihe von Umwandlungsprozessen native \gls{ios}-\glspl{built} aus bestehendem Java-\gls{android}-Code erstellt.

Eine weitere Möglichkeit, ein Programm plattformunabhängig zu nutzen, ist, mittels einer Client-Server Konzeption, ähnlich den \glspl{web-app}. Dieser Ansatz setzt natürlich eine Server-Infrastruktur voraus, ist aber beispielsweise für Firmen, die bereits eine Serveranwendung haben, die auf Mobilgeräten nutzbar gemacht werden soll, interessant.
Hier soll \gls{tabris} vorgestellt werden.

\gls{tabris} ist ein Framework, mit dem mobile Apps komplett in Java geschrieben werden können und dennoch native Bedienelemente von \gls{android}, \gls{ios} und \gls{html5} beinhalten.
Die eigentliche Anwendung wird dazu auf einem Server ausgeführt, auf dem die Funktionslogik läuft und alle Daten gespeichert werden. Die Apps auf den Mobilgeräten fungieren dann als Clients, die so die Benutzeroberfläche der Anwendung darstellen.
So steht für die Software die volle \gls{javaee} zur Verfügung.

Die Clients greifen auf die Server-Anwendung über eine URL zu, über die sie die Benutzeroberfläche als \gls{json} Repräsentation empfangen. Aus dieser wird dann durch den Client mit nativen Komponenten die Benutzeroberfläche gerendert. Diese sind \gls{cocao-touch-widgets} in \gls{ios}, Java-basierte Widgets in \gls{android} und \gls{html}5 in Webbrowsern.
Der Anwendungsentwickler muss sich um diesen Mechanismus allerdings nicht weiter kümmern. Das Programm wird als herkömmliche Java-Applikation entwickelt, wobei für die Benutzerschnittstelle das \gls{tabris-ui} zum Einsatz kommt.

\gls{tabris-ui} baut auf \gls{swt}, \gls{jface} und \gls{osgi} auf und ermöglicht es, im Gegensatz zu reinem \gls{swt}, auf viele native Bedien- und Navigationselemente zuzugreifen. Solche sind zum Beispiel die \gls{actionbar} von \gls{android}, die \glspl{viewCtrl} von Apple (welche für die Verwaltung angezeigten Inhalte in \gls{ios} zuständig sind) oder das Gesten-gesteuerte Blättern zwischen Seiten durch eine Wisch-Geste auf dem Display (engl. \enquote{swipe}). Weiter erhält der Entwickler über entsprechende \glspl{api} einfachen Zugriff auf viele Geräte-Funktionen und Interaktionen mit anderen Systemfunktionen wie beispielsweise Geolokalisierung oder Verknüpfung des Programms mit den Kommunikationsschnittstellen (Telefonieren, SMS, E-Mail, etc.).

\section{Entwicklung von hybriden Apps}	\label{sec:hybrid-dev}
%TODO boxed?

% Dieses Kapitel dient dazu, den Leser über die Grundlagen der im Praxis-Teil verwendeten Technologien zu setzten. Da ich im Praxis-Teil nur Cordova ausprobiere, hier der Zusatz "mit Cordova" in der Übeschrift?

Wie in \ref{sec:hybrid-app} beschrieben, bildet die hybride App-Entwicklung die Schnittmenge aus der nativen App-Entwicklung und der Web-Entwicklung mithilfe von Web-Technologien und zusätzlichen \glspl{framework} und Bibliotheken. 
Hier soll mit \gls{cordova}\,/\,\gls{phonegap} die konkrete Nutzung eines dieser \glspl{framework} und weitere verwendete Technologien wie \gls{ko} oder \gls{jqm} erläutert werden.

\subsection{Die \gls{js}-Bibliothek jQuery}

Bereits für die Entwicklung von reinen Web-Anwendungen stellen neben den grundlegenden Web-Technologien \gls{html}, \gls{css} und \gls{js} Erweiterungen wie die \gls{js}-Bibliothek \gls{jq} nützliche Hilfsmittel dar, die viele Funktionen gegenüber der Verwendung von \enquote{reinem} \gls{js} deutlich vereinfacht.
So ist beispielsweise der Programmieraufwand für den Zugriff auf Elemente einer \gls{html}-Seite durch \gls{jq} wesentlich geringer als ohne die Bibliothek.
Besonders deutlich wird dies an den unten aufgeführten Code-Beispielen, in denen ein Button exemplarisch die Funktionalität übernehmen soll, alle Absätze einer \gls{html}-Seite auszublenden.
Während bei herkömmlichem \gls{js} für die Selektion aller Elemente die Funktion \lstinline|getElementsByTagName()| aufgerufen werden muss (\seeref{lst:js}), ist bei \gls{jq} der Zugriff auf alle Elemente eines \glspl{tag} per Dollar(\lstinline|$|)-Notation deutlich verkürzt (\seeref{lst:jq}).
Auch die nächste Anweisung zur Ausführung einer Operation für alle ausgewählten Elemente (hier: \lstinline|hide()|, also \textit{ausblenden}) fällt bei \gls{jq} wesentlich kürzer aus, indem die Funktion noch in der selben Zeile wie der vorherigen Selektor aufgerufen werden kann (\lstinline|$("p").hide();|).
Bei der reinen \gls{js}-Variante ist nach der Selektion aller Absätze zunächst einmal ein Array ausgewählt, sodass, um auf den einzelnen Elementen Operationen ausführen zu können, durch alle Elemente des Arrays iteriert und die Funktion für jedes Element aufgerufen werden muss (\seeref{lst:js}, \linenamepl 5\,-\,7).

\includehtml{jquery.html}{
	label=lst:jq,
		caption=\gls{jq}-Beispiel-Code zum Ausblenden aller Absätze \cite{w3schools_jq_hide}.,
	}

\includehtml{without-jquery.html}{
	label=lst:js,
		caption=Die gleiche Funktionalität wie in \autoref{lst:jq} mit reinem \gls{js}.,
	}
	

\subsection{Data-Binding mit Knockout} \label{sec:ko}
Neben \gls{jq} bietet das \gls{ko}-\gls{framework} ein weiteres nützliches Hilfsmittel für die Entwicklung von Web-Anwendungen, das ebenso wie \gls{jq} und \gls{jqm} aus einer \gls{js}-Bibliothek besteht und die Verbindung der \gls{html}-Oberfläche mit der Programmlogik der Anwendung mittels \gls{data-binding}, also der dynamischen Anbindung von \gls{ui}-Komponenten zu Datenfeldern auf Programmebene, erheblich vereinfacht.
Das \gls{data-binding} wird bei \gls{ko} durch das \gls{mvvm} realisiert, das Entwicklern eine Trennung zwischen Benutzeroberfläche und \gls{ui}-Logik ermöglicht.
Diese Aufteilung dient unter anderem der Übersichtlichkeit des Codes und kann beispielsweise die Aufteilung der Entwicklung von Benutzerschnittstellen erleichtern, indem die \gls{ui}- und die Geschäftslogik von Softwareentwicklern übernommen werden kann, während Designer den Schwerpunkt auf die Gestaltung der Oberfläche legen können \cite{Model_View_ViewModel__Wikipedia}.

\image{mvvm-pattern}
	{width=1\textwidth}
	{MVVM-Pattern}
		{Schematische Darstellung des Entwurfsmusters MVVM: Die View ist über das \gls{data-binding} mit dem ViewModel verbunden, indem die UI-Logik implementiert ist und das mit der Geschäftslogik (Model) interagiert.}
	{Wikimedia Commons \cite{MVVMPattern}.}

Das \gls{mvvm} stellt eine Gliederung der Software in drei Grundlegende Komponenten dar:
Die \gls{view} repräsentiert die Präsentationsschicht, also die Benutzeroberfläche, im Falle der Web-Anwendung also die \gls{html}-Seite, deren Elemente per \gls{data-binding} an Eigenschaften des \glspl{view-model} gebunden werden können. 
Das \gls{model} steht für die Geschäftslogik und beinhaltet das Datenmodell und die Funktionen, die vom \gls{view-model} angefragt werden können, um beispielsweise Benutzereingaben zu validieren oder Daten für die Anzeige in der Oberfläche zu erhalten (\seeref{fig:mvvm-pattern}).

Ein wesentlicher Mechanismus für die Aktualisierung der Oberfläche bei einer Änderung des \glspl{view-model} von \gls{ko} ist die Verwendung von \glspl{obs}, also Objekten oder Datenfeldern, welche bei Änderungen ihres Inhalts eine Nachricht aussenden, sodass andere Objekte automatisch auf die Zustandsänderung des \glspl{obs} reagieren können, beispielsweise, um die Anzeige auf der Oberfläche zu aktualisieren.

Im Code-Beispiel unten (\autoref{lst:ko}) wird ein einfaches \gls{view-model} mit drei Eigenschaften erstellt: \lstinline|firstName|, \lstinline|lastName|, und \lstinline|fullName|, wobei die ersten beiden \emph{\glspl{obs}} darstellen und letztere aus den anderen beiden Feldern generiert wird (\linenamepl 10\,-\,13).
Durch den Aufruf der \gls{ko}-Funktion \lstinline|observable()| ist es nicht notwendig, bei einer Änderung der Daten an der Oberfläche, die Änderung der Anzeige der Daten (\linename 27) explizit anzustoßen (Beispielsweise per EventListener auf einer \gls{ui}-Komponente).
Stattdessen übernimmt das \gls{ko}-\gls{framework} die Durchreichung aller Änderungen im \gls{view-model}, sodass bei einer Benutzereingabe in eines der \lstinline|<input>|-Felder eine Änderung der Daten im \gls{view-model} registriert wird und automatisch alle damit verbundenen \glspl{view} aktualisiert werden (\seeref{fig:ko-hello-world}).\footnote{Hier das \texttt{<h2>}-Element, das mit der \gls{view-model}-Eigenschaft \texttt{fullName} verknüpft ist.}

\includehtml{ko.html}{
	label=lst:ko,
		caption=Einfaches Anwendungsbeispiel für die Verwendung der \gls{js}-Bibliothek \gls{ko}.,
	}

\image{ko-hello-world}
	{width=1\textwidth}
	{Knockout-Beispiel im Browser}
		{Knockout-Beispiel aus \autoref{lst:ko} im Browser. Links im Bild: Anzeige bei Initialisierung der Oberfläche, rechts: Benutzereingabe ins Eingabefeld: \enquote{Mars}. \\ Änderungen in der UI (Hier: im Eingabefeld) werden sofort im \gls{view-model} registriert und automatisch an alle verknüpften Anzeigen weitergereicht (Hier an das fettgedruckte Begrüßungselement).}
	{Eigener Screenshot.}

\subsection{JQuery\,Mobile: Mobile Web-Oberflächen}

%TODO Hier Evtl. auch nochmal Bezug nehmen auf Überblick: Was gibts für GUI-Libs?

Um das Erscheinungsbild und Verhalten von Webseiten an eine bessere Benutzung für mobile Geräte anzupassen, bietet sich der Einsatz eines entsprechenden \gls{gui}-Toolkits an. 
Die von der \gls{jq-foundation} entwickelte \gls{gui}-Bibliothek \gls{jqm} bietet hier Möglichkeiten für Entwickler von mobilen Webseiten, ihre Dokumente an verschiedene Eigenschaften anzupassen, die gemeinhin unter dem Begriff \gls{laf} zusammengefasst werden, wie dem äußeren Erscheinungsbild, der Fähigkeit, mit Touch-Gesten umzugehen, der Anpassung an die geringere Display-Größe sowie von vielen mobilen \glspl{app} gewohnten Animationen, und somit erwartungskonform zu gestalten.

\Gls{jqm} besteht mit einer \gls{js}-Bibliothek und einem zusätzlichen Stylesheet in \gls{css}, aus zwei Dokumenten, deren Einbindung in die \gls{html}-Seite analog zu der von \gls{jq} per Verlinkung als \lstinline|<script>|- beziehungsweise \lstinline|<link>|-\gls{tag} funktioniert.
Da \gls{jqm} auf \gls{jq} aufbaut, muss auch der Link zum \gls{jq}-Script gesetzt sein, um auf die benötigten Funktionen zugreifen zu können (\seeref{lst:jqm}, \linenamepl 3\,-\,5).

\includehtml{jquerymobile.html}{
	label=lst:jqm,
		caption=Einbindung von \gls{jqm} in eine \gls{html}-Seite \cite{w3schools_jqm_start}.,
	}
	
Die Definition von \gls{gui}-Elementen geschieht hierbei über das \gls{html}-Attribut \lstinline|data-role|, dem vordefinierte Werte wie \lstinline|page|, \lstinline|header|, \lstinline|footer|, \lstinline|button| u.\,v.\,a.\,m. zugeteilt werden können, anhand derer das \gls{jqm}-\gls{framework} den \gls{html}-Elementen die jeweilige Style-Definition aus dem Stylesheet zuweisen kann (\seeref{lst:jqm}, \linenamepl 8, 9, 12 und 15).
Somit wird dem Entwickler ermöglicht, ohne zusätzlichen Entwicklungsaufwand für die Programmierung von \gls{gui}-Komponenten oder Erstellung von Style-Definitionen Webseiten mit zeitgemäßem und adäquaten \gls{laf} für mobile Geräte anzupassen (\seeref{fig:jqm} und \ref{fig:without-jqm}).

Neben der Zuweisung von Rollen über das \lstinline|data-role|-Attribut, durch die das \gls{framework} den \gls{gui}-Komponenten automatisch entsprechende Style-Definitionen zuweist, können weiterhin über das \lstinline|class|-Attribut direkt Style-Klassen aus dem \gls{jq}-Stylesheet verwendet werden.
Beispielsweise sorgt im obigen Beispiel der Zusatz \lstinline|class="ui-content"| (\autoref{lst:jqm}, \linename 12) für ein besseres Layout des \lstinline|<div>|-Inhalts, wie der Vergleich ohne das \lstinline|class|-Attribut in \autoref{fig:without-ui-content-class} zeigt.


\image{jqm}
	{width=1\textwidth}
	{jQuery\,\-Mobile-Beispiel}
	{jQuery\,\-Mobile-Beispiel aus \autoref{lst:jqm} im Browser.}
	{Eigener Screenshot.}

\image{without-ui-content-class}
	{width=1\textwidth}
	{Beispiel ohne \lstinline|class|-Attribut}{Beispiel-Oberfläche wie in \autoref{fig:jqm}, ohne das class-Attribut in \autoref{lst:ko}, \linename 12.}
	{Eigener Screenshot.}

\image{without-jqm}
	{width=1\textwidth}
	{Beispiel ohne jQuery\,\-Mobile}{Beispiel-Oberfläche wie in \autoref{fig:jqm}, aber ohne die \gls{jqm}-Bibliotheken.}
	{Eigener Screenshot.}

\subsection{Phonegap\,/\,Cordova} \label{sec:cordova}

% Vorstellung ----------------------------------------------

\subsubsection{Grundlegendes} \label{sec:cordova-grundlegendes}

\gls{phonegap} ist ein \gls{opensource}-\gls{framework} von \gls{adobe} zur Erstellung von hybriden \glspl{app} und bildet damit die Grundlage für den hier explorierten Ansatz zur plattformunabhängigen \gls{app}-Entwicklung.
Die Software wurde ursprünglich unter dem Namen \gls{phonegap} von der Firma \gls{nitobi} entwickelt, die 2011 von \gls{adobe} aufgekauft wurde \cite{Adobe_Announces_Agreement_to_Acquire_Nitobi_Creator_of_PhoneGap}. 
Später wurde die Code-Basis der \gls{apache} übergeben und dort in \gls{cordova} umbenannt, wodurch das \gls{framework} in den Quellen stellenweise unter beiden Namen erscheint.
\Gls{adobe} \gls{phonegap} baut also als dessen Distribution auf \gls{cordova} auf, wobei derzeit der einzige wesentliche Unterschied im Namen des Pakets besteht (Stand: \citedate{PhoneGap_Cordova_and_whats_in_a_name}), nach eigenen Angaben aber durchaus weitere Tools mit Bezug auf andere \gls{adobe}-Dienste in die \gls{phonegap}-Distribution einfließen können \cite{PhoneGap_Cordova_and_whats_in_a_name}.

Da das \gls{apache}-\gls{framework} als \gls{opensource}-Basis auch die allgemeine Grundlage für weitere \gls{cordova}-Distributionen bildet und so auch die Community-Anlaufstelle zur Mitwirkung am \gls{cordova}-Projekt darstellt~\cite{PhoneGap_Cordova_and_whats_in_a_name}, wird im Folgenden weitgehend der Begriff \enquote{\gls{cordova}} verwendet, die meisten Inhalte treffen aber ebenso auf die \gls{adobe}-Version \gls{phonegap} zu. \todo{Oder ist das nicht eigentlich eh klar, da Cordova du \emph{Grundlage} bildet?}
%TODO Nach praktischem Teil nochmal checken!

% Beschreibung / Übersicht: Komponenten --------------------

Wie in \autoref{sec:hybrid-app} beschrieben, wird bei der hybriden App-Entwicklung eine \gls{web-app} programmiert, die dann in einen nativen \gls{app}-Container \enquote{verpackt} werden und somit auf dem jeweiligen Mobilgerät als mobile App ausgeführt werden kann. 
Das \gls{cordova}-\gls{framework} besteht darüber hinaus im Wesentlichen aus einer \gls{api} in Form einer \gls{js}-Bibliothek, die es dem Entwickler ermöglicht, auf native Funktionalitäten des mobilen Betriebssystems zuzugreifen sowie einem mitgelieferten \gls{cli}, das für die Erstellung, Erweiterung und Anpassung der Anwendung, zur Bewerkstelligung des Build-Prozesses für die verschiedenen \glspl{plattform} sowie auch der Ausführung in einem Emulator oder auf einem Mobilgerät zum Testen der Anwendung dient \cite{Cordova-Docs_Overview}.

% Entwicklungsworkflows ------------------------------------

In der Cordova-Dokumentation werden zwei grundlegende Entwicklungsszenarien beschrieben, für die das \gls{framework} verwendet werden kann. 
Mit der Version 3.0 wurde das \gls{cli} Teil des Software-Paktes, das viele Arbeitsschritte automatisiert ausführt und damit den Cordova-Entwicklungsprozess vereinfacht. 
Der Hauptfokus dieses Werkzeugs liegt im für die hybride App-Entwicklung grundlegenden Entwicklungsworkflows, dem \emph{Web-Ent\-wick\-lungs\-an\-satz}.
Dieser Ansatz bietet die breiteste Plattformunterstützung bei möglichst geringem Mehraufwand für unterschiedliche \glspl{plattform} und bildet damit die Grundlage für den hier hauptsächlich fokussierten Ansatz \cite{Cordova-Docs_CLI}.

Soll nur eine bestimmte Zielplattform bedient werden, kann auch nach dem \emph{Nativen-Plattformansatz} entwickelt werden.
Dabei wird das \gls{cli} in erster Linie für die Erstellung des Grundgerüsts der App verwendet, dessen Web-Oberfläche und nativer Kern dann mithilfe einer entsprechenden \gls{ide} in Kombination mit einem \gls{sdk} der jeweiligen \gls{plattform} weiter verarbeitet und kompiliert werden können. 
Dieser Ansatz kann beispielsweise sinnvoll sein, wenn Entwickler mobiler Apps ihre Kenntnisse im Web-Bereich für die mobile \gls{app}-Entwicklung nutzen möchten und sehr plattformspezifische Eigenschaften angepasst werden sollen, ist aber aufgrund des Mangels an entsprechenden Tools nicht oder nur gering für die Entwicklung plattformunabhängiger \glspl{app} geeignet \cite{Cordova-Docs_CLI}. 

% Plattform- / Feature-Unterstützung -----------------------

\image{cordova-platform-support}
	{width=\fullimagesize}
	{Cordova Plattform- und Feature-Unterstützung}
		{Plattform- und Feature-Unterstützung des \gls{cordova}-\glspl{framework}: \\ 
		Bis auf wenige (\enquote{kleinere}) mobile Betriebssysteme bietet \gls{cordova} auch über die am weitesten verbreiteten \glspl{plattform} wie \gls{android}, \gls{ios} und \gls{win-phone} hinaus die volle Feature-Unterstützung für \gls{amazon-fireos}, \gls{ubuntu-phone} und eine fast vollständige für \gls{blackberry-os}.\\
		Für Entwickler von hybriden \glspl{app} dürfte hier auch vor allem die erste Zeile \emph{cordova CLI} interessant sein, da durch die Kompatibilität der jeweiligen Plattform-\glspl{sdk} nur bestimmte Kombinationen von Entwicklungs- und Zielplattform möglich sind.}
	{Screenshot aus der \gls{cordova}-Dokumentation \cite{Cordova-Docs_Platform-Support}.}

% Voraussetzungen ------------------------------------------

\gls{cordova} stellt für die Verwendung von nativen Funktionalitäten des mobilen Betriebssystems mit seiner \gls{js}-Plattform-\gls{api} eine Verbindung von der Web-Anwendungsebene zu den jeweiligen \glspl{sdk} der Zielplattformen her.
Somit müssen, um auf plattformspezifische Features zugreifen zu können, auf der Entwicklungsplattform alle \glspl{sdk} der gewünschten Zielplattformen installiert sein.
Da die \glspl{sdk} jedoch teilweise nur von bestimmten Desktop-Betriebssystemen unterstützt werden, muss das \gls{cli} unter Umständen auf mehreren Rechnern ausgeführt werden, die jeweils nur bestimmte mobile \glspl{plattform} bedienen (\seeref{fig:cordova-platform-support}).

% Funktionsweise -------------------------------------------
\subsubsection{Funktionsweise}

Nachdem das \gls{cordova}-\gls{framework} auf dem Entwicklungsrechner installiert ist, kann mit dem \gls{cli} ein neues App-Projekt angelegt werden. 
Dazu muss auf der Kommandozeile in das Entwicklungsverzeichnis für das zu erstellende Projekt navigiert und das \gls{cordova}-Tool mit dem \lstinline|create|-Befehl aufgerufen werden (\seeref{lst:cordova-create}).

\includebash{cordova-create}{
	caption={Befehl zum Erstellen einer Cordova-App.},
	}

Das erste Argument \lstinline|hello-beuth| spezifiziert dabei den Namen des Ordners für das zu erstellende App-Projekt, der mit dem \lstinline|create|-Befehl angelegt wird.
Die anderen beiden Parameter sind optional und geben mit der \gls{id} in der rückwärts geschriebenen Domain-Bezeichnung und dem Namen ({\mbox{\enquote{HelloBeuth}}), der später für die App angezeigt wird, weitere Informationen für die App an, die in einer \gls{xml}-Datei im neu angelegten Projekt-Ordner gespeichert werden \cite{Cordova-Docs_CLI}.

Mit der Ausführung dieses Skripts erstellt das Tool in einem neuen Ordner ein Grundgerüst für die \gls{app}, das die nötige Struktur für den weiteren Entwicklungsprozess enthält (\seeref{fig:cordova-directory}).
Auf oberster Ebene liegt die Konfigurationsdatei \filename{config.xml}, in der grundlegende Eigenschaften sowie Informationen für den Build-Prozess hinterlegt werden können (\seeref{lst:config.xml}).
Daneben werden unter anderem (zu diesem Zeitpunkt noch leere) Ordner für \glspl{plugin} und plattformspezifischen Code sowie ein \filename{www}-Ordner angelegt, der das Grundgerüst für den Web-Teil der \gls{hybrid-app} beinhaltet.
Neben der Datei \filename{index.html}, die die Beschreibung der Web-Oberfläche für die Anwendung darstellt, werden nach üblichen Konventionen in der Webentwicklung weiterhin die Unterordner \filename{js}, \filename{css} und \filename{img} angelegt, worin die zur \gls{app} gehörigen \gls{js}- und \gls{css}-Dateien bzw. Bilder gespeichert werden~\cite{Cordova-Docs_CLI}.


\image{cordova-directory}
	{resolution=\screenshotRes}
	{Cordova-Dateistruktur}
		{Dateistruktur einer mit \gls{cordova} erstellten \gls{app}. Das Grundgerüst für die \gls{hybrid-app} wird automatisch angelegt und entspricht den üblichen Web-Entwicklungskonventionen.}
	{Eigener Screenshot.}


\includehtml{hello-beuth/config.xml}{
	label=lst:config.xml,
		caption={Die Konfigurationsdatei \filename{config.xml}, in der allgemeine Informationen über die \gls{hybrid-app} gespeichert werden. In \linename 2 und 4 tauchen die in \autoref{lst:cordova-create} angegebenen optionalen  Parameter \emph{Id} und \emph{Name} wieder auf.},
	}
	

Die Initialisierung der \gls{app} erfolgt über den \filename{deviceready}-Eventhandler, der standardmäßig von \filename{www/js/index.js} referenziert wird (\seeref{lst:index.html}, \linename 21 und \autoref{lst:index.js}, \linenamepl 11\,u.\,12).

Das in \linename 18 referenzierte Script \lstinline|cordova.js| stellt die \og wesentliche \gls{api} zur nativen Betriebssystemebene dar, ist hier im \filename{www}-Ordner jedoch noch nicht vorhanden, sondern wird erst nach Ausführung des \lstinline|build|-Befehls in seiner jeweiligen plattformspezifischen Ausführung in das entsprechende Unterverzeichnis im Ordner \filename{platforms} eingefügt. 

\includehtml{hello-beuth/www/index.html}{
	firstline=20,
	lastline=43,
	label=lst:index.html,
		caption={Startseite der von \gls{cordova} erzeugten \gls{app}, die auf das \lstinline|deviceready|-Event reagiert.},
	}

\includehtml{hello-beuth/www/js/index.js}{
	firstline=19,
	lastline=49,
	label=lst:index.js,
		caption={Standardmäßig von \gls{cordova} angelegte \gls{js}-Datei \filename{index.js}},
	}

Um die Oberfläche der \gls{app} anzuzeigen, lässt sie sich, da sie im Wesentlichen aus einer \gls{html}-Seite besteht, in einem herkömmlichen Browser öffnen (\seeref{fig:cordova-app-browser}).
Da jedoch das bei der hybriden \gls{app} darunterliegende mobile Betriebssystem hier nicht zur Verfügung steht, ist hier auch keine Anbindung an dessen Funktionalitäten möglich.
Dafür muss die Anwendung entweder direkt auf einem mobilen Gerät, dessen \gls{plattform} die \gls{app} und das \gls{cordova}-\gls{api} unterstützen, oder mithilfe eines Emulators ausgeführt werden (\seeref{fig:android_emulate_install}) \cite{Cordova-Docs_CLI}.

\image{cordova-app-browser}
	{resolution=\screenshotRes}
	{Cordova-Beispiel-App im Browser}
		{Die Startseite der Beispiel-App aus \autoref{lst:index.html} lässt sich auch im Desktop-Browser öffnen und anzeigen, allerdings kann hier kein \lstinline|deviceready|-Event empfangen werden.}
	{Eigener Screenshot.}

\image{android_emulate_install}
	{width=1\textwidth}
	{Cordova-Beispiel-App im \gls{android}-Emulator}
		{Anzeige in der App-Übersicht (links) und Ausführung der Cordova-Beispiel-App in einem \gls{android}-Emulator (rechts). Das grüne Label zeigt den Empfang des \lstinline|deviceready|-Events an.}
	{\gls{cordova}-Dokumentation \cite{android_emulate_install.png}}

Bevor die \gls{hybrid-app} mit \gls{cordova} zum Laufen gebracht werden kann, muss sie, wie die meisten Computerprogramme, in ein ausführbares Format überführt, also \emph{gebaut} werden.
Im Falle der \gls{hybrid-app} bedeutet das, dass diejenigen plattformspezifischen Komponenten der \gls{app} hinzugefügt werden, die nötig sind, um die Verbindung zwischen der plattformunabhängigen Web-Schicht und der nativen Schicht des jeweiligen Zielbetriebssystems herzustellen.

Damit das \gls{cordova}-\gls{framework} die entsprechenden Schnittstellen in die Anwendung einfügen kann, muss vor dem Build-Prozess ein Satz an Zielplattformen angegeben werden. 
Voraussetzung hierfür ist, dass die \glspl{sdk} der jeweiligen Zielplattformen zu der verwendeten Entwicklungsplattform kompatibel und installiert sind \cite{Cordova-Docs_CLI}.

Über den \gls{cordova}-Befehl \lstinline|platform| lassen sich mit den Optionen \lstinline|add| und \lstinline|remove| \glspl{plattform} zur Projektkonfiguration der Anwendung hinzufügen bzw. entfernen (\seeref{lst:cordova-platform-add-remove}).
Die Ausführung dieser Befehle wirkt sich auf den Inhalt des \filename{platforms}-Ordners innerhalb der Projektstruktur aus \cite{Cordova-Docs_CLI}.

\includebash{cordova-platform-add-remove}{
	caption={\gls{cordova}-Skript um \glspl{plattform} zum Projekt hinzuzufügen bzw. zu entfernen. \linename 1 fügt die \gls{plattform} \gls{android} hinzu, \linename 2 entfernt diese wieder.},
	}

Der \lstinline|list|-Befehl dient dazu, eine Liste aller \glspl{plattform} des Projekts auszugeben. Wie bei den meisten anderen Befehlen auch, kann synonym auch eine Kurzschreibweise (\lstinline|ls|) verwendet werden (\seeref{lst:cordova-platform-list}).

\includebash{cordova-platform-list}{
	caption={\gls{cordova}-Skript zum Auflisten aller \glspl{plattform} des Projekts.},
	}

Anschließend kann mit dem \lstinline|build|-Befehl die \gls{app} gebaut werden:
\includebash{cordova-build}{
	caption={Bauen der \gls{cordova}-\gls{app} für \gls{android}.},
	}


Der \lstinline|build|-Befehl stellt dabei eine Kurzform für die beiden Befehle \lstinline|prepare| und  \lstinline|compile| dar (\seeref{lst:cordova-prepare-compile}).
Diese Aufteilung kann beispielsweise sinnvoll sein, um erst den \lstinline|prepare|- Befehl auszuführen und den plattformspezifischen Code, den Cordova in \filename{platforms/android} generiert, anschließend mit einer entsprechenden \gls{ide} (wie beispielsweise \gls{android-studio}) und deren nativem \gls{sdk} anzupassen und zu kompilieren.\footnote{\vgl Nativ-Entwicklungsansatz, \seeref{sec:cordova-grundlegendes}.}


\includebash{cordova-prepare-compile}{
	caption={Ausführlichere Schreibweise für den \lstinline|build|-Befehl aus \autoref{lst:cordova-build}.},
	}


Ist der Build-Prozess abgeschlossen, kann die fertige \gls{app} auch mit dem \gls{cordova}-\gls{cli} getestet werden. 
Die Anwendung kann dafür entweder an einen Emulator, der in vielen Fällen mit dem jeweiligen \gls{sdk} mitgeliefert wird, übergeben (\seeref{lst:cordova-emulate}) oder direkt auf einem an den Entwicklungsrechner angeschlossenen Mobilgerät ausgeführt werden (\seeref{lst:cordova-run}).
Für letzteres müssen unter Umständen noch entsprechende Einstellungen auf dem Gerät vorgenommen werden \cite{Cordova-Docs_CLI}.

\includebash{cordova-emulate}{
	caption={Übergibt die \gls{app} an den Emulator des \gls{android}-\glspl{sdk}.},
	}

\includebash{cordova-run}{
	caption={Führt die \gls{app} auf einem angeschlossenen Mobilgerät aus.},
	}

\subsubsection{Schnittstelle zur mobilen Plattform}

Um den eigentlichen Mehrwert des \gls{cordova}-\glspl{framework} zu nutzen, also auf native Features der Zielplattformen zuzugreifen, sind verschiedene \glspl{plugin} nötig, die ebenfalls mit dem \gls{cli} verwaltet werden können.
\glspl{plugin} bestehen aus einem zusätzlichen Stück Code, der die Kommunikation zu den nativen Komponenten herstellt.
\gls{cordova} bietet von Haus aus einen Basissatz von ca. 17 Kern-\glspl{plugin} an,\footnote{In den Quellen finden sich teilweise unterschiedliche Informationen über die Anzahl der Basis-\glspl{plugin}. In der offiziellen \gls{cordova}-Dokumentation werden folgende aufgelistet: \emph{Battery Status, Camera, Contacts, Device, Device Motion (Accelerometer), Device Orientation (Compass), Dialogs, FileSystem, File Transfer, Geolocation, Globalization, InAppBrowser, Media, Media Capture, Network Information (Connection), Splashscreen} und \emph{Vibration} \cite{Cordova_Docs_Plugin_APIs}. Auf der \gls{cordova}-Homepage finden sich zudem noch die beiden Einträge \emph{Console} und \emph{Statusbar} \cite{Apache_Cordova_Contribute}.} es können aber auch eigene entwickelt werden.\footnote{So bietet \zB \gls{adobe} mit seiner \gls{phonegap}-Variante noch einige weitere \glspl{plugin} wie beispielsweise den Zugriff auf einen angeschlossenen Barcode-Scanner an, die über die Grundausstattung von \gls{cordova} hinausgehen \cite{Cordova-Docs_CLI}.}
Für die Erstellung und Veröffentlichung eigener \glspl{plugin} stellt \gls{apache} in seiner \gls{cordova}-Dokumentation eine Entwicklungsanleitung bereit \cite{Cordova_Plugin_Development_Guide}.

\paragraph{Einrichten von Plugins:}

Für die Installation und Dokumentation von \glspl{plugin} bietet \gls{apache} mit der \gls{plugin-registry} ein Online-Portal an, in der sich zur Zeit 229 \glspl{plugin} für das \gls{cordova}-\gls{framework} finden, darunter auch die \og Kern-\glspl{plugin} von \gls{apache} \cite{Cordova_Docs_Plugin_APIs}. Der überwiegende übrige Teil stammt von verschiedenen Entwicklern und Drittanbietern, die ihre nach dem \gls{plugin-dev-guide} entwickelten \glspl{plugin} diesem Portal hinzufügen können \cite{Cordova_Plugin_Development_Guide}, und bieten häufig spezielle Unterstützung für bestimmte mobile Plattformen an \cite{Cordova_Plugin_Registry_viewAll}.

Das \gls{cordova}-\gls{cli} bietet auch die Möglichkeit, alle verfügbaren \glspl{plugin} zu durchsuchen, hinzuzufügen, aufzulisten und zu entfernen (\seeref{lst:cordova-plugin-search}, \ref{lst:cordova-plugin-add}, \ref{lst:cordova-plugin-ls} und \ref{lst:cordova-plugin-rm}).


\includebash{cordova-plugin-search}{
	caption={Suchen von verfügbaren \glspl{plugin}.},
	}

\includebash{cordova-plugin-add}{
	caption={\gls{plugin} zur App hinzufügen.},
	}

\includebash{cordova-plugin-ls}{
	caption={Analog zum \lstinline|list|-Befehl für \glspl{plattform} (\seeref{lst:cordova-platform-list}) können auch \glspl{plugin} des aktuellen Projekts aufgelistet werden.},
	}

\includebash{cordova-plugin-rm}{
	caption={\gls{plugin} entfernen.},
	}

\paragraph{Verwendung von Plugins}	\label{sec:cordova-plugins-verwendung}

\gls{cordova}-\glspl{plugin} können einen Satz von Methoden und Objekttypen mitbringen, mit deren Hilfe Entwickler die Funktionen der jeweiligen \glspl{plugin} nutzen können.
So beinhaltet beispielsweise das \emph{contacts}-\gls{plugin} für den Zugriff auf die native Adressverwaltung des Geräts neben dem zentralen \lstinline|Contact|-Objekt, das eine Instanz eines Eintrags im Adressbuch des Geräts repräsentiert, die Typen \mbox{\lstinline|ContactName|,} \mbox{\lstinline|ContactField|,} \mbox{\lstinline|ContactAddress|,} \mbox{\lstinline|ContactOrganization|,} die einige der Attribute des \lstinline|Contact|-Objekts darstellen sowie das Konfigurationsobjekt \mbox{\lstinline|ContactFindOptions|,} das bestimmte Optionen für den Zugriff auf das Adressbuch kapselt und einen \mbox{\lstinline|ContactError|,} welcher bei Auftreten eines Fehlers, beispielsweise bei der Suche nach Kontakten, behandelt werden kann \cite{Cordova_Plugin_Registry_Contacts}.

Darüber hinaus können hier die beiden Methoden \lstinline|navigator.contacts.create| und \lstinline|navigator.contacts.find| verwendet werden, um neue Kontaktobjekte zu erstellen bzw. zu suchen (\seeref{sec:contacts}).
Das Präfix \lstinline|navigator| identifiziert ein elementares Objekt des \gls{js}-Kerns, das in der Webentwicklung Informationen über den verwendeten Webbrowser bereitstellt, wie beispielsweise den Namen oder dessen Version sowie Informationen über aktivierte Browserplugins \cite{selfhtml_navigator}.
Das \gls{cordova}-\gls{framework} ersetzt mittels seiner zentralen, plattformspezifischen \gls{js}-Datei \filename{cordova.js} das \gls{js}-Objekt \lstinline|navigator| durch einen eigenen \lstinline|CordovaNavigator| \cite{cordova.js_replaceNavigator}, dem dann durch die verschieden \glspl{plugin} neue Eigenschaften und Methoden zugewiesen werden können über die der Zugriff auf verschiedene \glspl{plugin} bewerkstelligt werden kann, wie in diesem Beispiel das \lstinline|contacts|-Objekt, welches die beiden \gls{plugin}-Methoden \lstinline|create| und \lstinline|find| beinhaltet.
Der \og \gls{js}-Objekttyp \lstinline|Contact| ist in der \gls{contacts-api} definiert und beinhaltet die Felder \mbox{\lstinline|id|,} \mbox{\lstinline|displayName|,} \mbox{\lstinline|name|,} \mbox{\lstinline|nickname|,} \mbox{\lstinline|phoneNumbers|,} \mbox{\lstinline|code|,} \mbox{\lstinline|addresses|,} \mbox{\lstinline|ims|,} \mbox{\lstinline|organizations|,} \mbox{\lstinline|birthday|,} \mbox{\lstinline|note|,} \mbox{\lstinline|photos|,} \lstinline|categories| und \lstinline|urls| sowie die Methoden \lstinline|clone| zum duplizieren von Kontaktinstanzen, \mbox{\lstinline|remove|,} um Kontakte aus dem Adressbuch zu entfernen und \mbox{\lstinline|save|,} mit der sich neu erstellte Kontakte in der Adressverwaltung des Geräts abspeichern lassen \cite{cordova-plugin-contacts}.
%TODO was sollte wohin? das sind doch schon wieder grenzen und möglichkeiten und sollte daher vielleicht eher umsetzung?

Je nach Aufgabengebiet unterscheiden sich die verschiedenen \glspl{plugin} in ihrer Verwendung.
Während bei einigen, wie \zB dem \gls{cordova}-\gls{plugin}, Schnittstellenmethoden über das \lstinline|navigator|-Objekt bereitgestellt werden (\seeref{lst:cordova-plugin-contacts}), bieten andere wie bspw. das \emph{Battery-Status}-\gls{plugin} die Behandlung verschiedener Events an,\footnote{Im Beispiel des \emph{Battery-Status}-\glspl{plugin} geben diese Auskunft über eine Statusänderung des Ladezustands oder den Anschluss an ans Stromnetz \cite{Cordova_Plugin_Registry_battery-status}.} die über das Hinzufügen eines \glspl{event-handler} zum \lstinline|window|-Objekt\footnote{Ähnlich wie das \lstinline|navigator|-Objekt ist auch das \lstinline|window|-Objekt Bestandteil der \gls{js}-Spezifikation, das Eigenschaften und Methoden zur Information und Steuerung des Browser-Fensters  bietet \cite{selfhtml_window}.} verarbeitet werden können (\seeref{lst:cordova-plugin-battery-status}) und wieder andere, wie \zB das \emph{Device}-\gls{plugin} stellen ein bestimmtes Objekt bereit, über das in diesem Fall Informationen abgefragt werden können \cite{Cordova_Plugin_Registry_Contacts, Cordova_Plugin_Registry_battery-status, Cordova_Plugin_Registry_device}.\footnote{In diesem Beispiel über das verwendete Gerät (\seeref{lst:cordova-plugin-device}).}

\includehtml{cordova-plugin-contacts.js}{label=lst:cordova-plugin-contacts, caption={Beispiel für die Verwendung des \emph{Contacts}-\glspl{plugin} für die Erstellung eines neuen \lstinline|Contact|-Objekts \cite{Cordova_Plugin_Registry_Contacts}.},}

\includehtml{cordova-plugin-battery-status.js}{label=lst:cordova-plugin-battery-status, caption={Beispiel für die Verwendung des \emph{Battery-Status}-\glspl{plugin} \cite{Cordova_Plugin_Registry_battery-status}.},}

\includehtml{cordova-plugin-device.js}{label=lst:cordova-plugin-device, caption={Beispiel für die Verwendung des \emph{Device}-\glspl{plugin}. Bei Empfang des \emph{DeviceReady}-\glspl{event} wird die Modell-Bezeichnung des Geräts in der Konsole ausgegeben \cite{Cordova_Plugin_Registry_device}.},}

\subsubsection{PhoneGap\,Build}	%TODO Evtl. umbenennen in "Remote Build Services" od. "Der Build-Prozess" oder so.
%TODO Gliederung: Eher als Alternative zum lokalen Build?

%TODO Noch grundsätzlicher einleiten: Es gibt auch Cloud-Build-Services wie zB.....

Mit seinem Online-Portal \gls{pg-build} bietet \gls{adobe} einen webbasierten Build-Service für \gls{phonegap}-Apps an, der den Bau-Prozess, im Falle der hybriden \glspl{app} also die eigentliche Anbindung an plattformspezifische Toolkits auf nativer Ebene sowie das Einbetten der \gls{web-app} in eine native \gls{web-view}, auslagert und damit deutlich vereinfacht.

Wie in \autoref{fig:hybrid-apps-schaubild} dargestellt, muss dieser Entwicklungsschritt im Gegensatz zu den vorherigen\footnote{Also der Entwicklung des Codes und der Oberfläche sowie Tests.} trotz (oder gerade wegen) des plattformunabhängigen Charakters mehrfach (also einmal für jede Zielplattform) ausgeführt werden, um die vorher entwickelte \gls{web-app} in die Umgebung einer nativen App einzubetten (\seeref{sec:hybrid-app}).
Dabei kann unter anderem besonderer Mehraufwand auf der administrativen Ebene entstehen, da, wie im \autoref{sec:cordova} beschrieben, nicht jede Entwicklungsplattform zu den gewünschten Zielplattformen kompatibel ist, und somit für die Verwaltung der verschiedenen \glspl{sdk} und das Bauen der jeweiligen hybriden \glspl{app} der Einsatz mehrerer Entwicklungsplattformen nötig sein kann, sofern ein breites Spektrum an Zielplattformen angestrebt wird.

Um also nicht auf gar mehreren Entwicklungsrechnern sämtliche Toolkits aller erforderlichen Zielplattformen verwalten zu müssen, können \gls{phonegap}-Entwickler hier ihren Quellcode hochladen und die App für die verschiedenen Zielplattformen im jeweiligen Format zusammenbauen bauen lassen.
Allerdings bietet auch \gls{pg-build} nicht für sämtliche mobilen \glspl{plattform}, die von \gls{cordova}\,/\,\gls{phonegap} unterstützt werden, seinen Service an.
Während bis Version 2.9 noch \glspl{app} für \gls{ios}, \gls{android}, \gls{win-phone}, \gls{blackberry-os}, \gls{webos} und \gls{symbian} in dem Portal gebaut werden konnten,
sind ab der Version 3.0 nur die drei größten Betriebssysteme \gls{ios}, \gls{android} und \gls{win-phone} verfügbar \cite{PhoneGap_Build_Documentation_Supported-Platforms}.

Um den Build-Prozess über den Cloud-Build-Service einzuleiten, erstellt der Entwickler eine \gls{web-app} in seiner gewohnten \gls{ide} in Form von \gls{html}-, \gls{js}- und \gls{css}-Dokumenten, die er anschließend auf \gls{pg-build} hochlädt.
Hierfür muss zunächst über die Web-Oberfläche des Portals eine neue \gls{app} angelegt werden.

Abhängig vom jeweiligen Bezahlpaket haben \gls{phonegap}-Entwickler die Möglichkeit, ihre Anwendung als private oder öffentliche \gls{app} hochzuladen. 
Während private \glspl{app} entweder als Zip-Paket hochgeladen oder als Link zu einem \gls{git}-Repository\footnote{Beispielsweise wie die öffentlichen Apps auf \gls{github} gehosted oder einem eigenen \gls{git}-Repository} in \gls{pg-build} eingestellt werden können (\seeref{fig:phonegap-build_create-public}), müssen öffentliche (also \gls{opensource}-) \glspl{app} in Form eines \gls{github}-Repositorys zugänglich gemacht werden.

\begin{quoting}
\enquote{We only allow open-source apps to be built from public Github repos}~\cite{PhoneGap_Build_Apps}
\end{quoting}


\image{phonegap-build_create-public}
	{width=1\textwidth}
	{Erstellung einer neuen App auf PhoneGap\,Build}
		{Dialog für die Erstellung einer neuen privaten \gls{app} auf \gls{pg-build}. Links das Eingabefeld zum Eintragen eines \gls{git}-Repository-Links und rechts der Button zum Hochladen von Zip-Archiven.}
	{Eigener Screenshot.}

Neben der Bezahlvariante gibt es auch ein kostenloses Paket, das eine private \gls{app} beinhaltet, bei der kostenpflichtigen Variante sind bis zu 25 private App enthalten.
\gls{opensource}-\glspl{app} können bei allen Paketen unbegrenzt angelegt werden (\seeref{fig:phonegap-build_plans}).

\image{phonegap-build_plans}
	{width=1\textwidth}
	{PhoneGap\,Build-Pakete}
		{Übersicht über die verschiedenen Bezahlpakete von \gls{pg-build}: Ab 9,99\,\$ im Monat können Entwickler bis zu 25 private \glspl{app} anlegen, in der kostenlosen Variante nur eine private, aber unbegrenzt öffentliche.}
	{Eigener Screenshot \cite{Adobe_PhoneGap_Build_Plans}.}

Nach dem Hochladen des Codes auf \gls{pg-build}, wird dort automatisch der Build-Prozess für die \glspl{hybrid-app} initiiert.
Dabei sorgt \gls{pg-build} dafür, dass für jede \gls{plattform} die entsprechende \gls{phonegap}-\gls{js}-Bibliothek %TODO Checken (auch im Rest vom Text): cordova.js ist glaub ich gar keine Bibliothek!
 injiziert wird, welche die \gls{api} zur nativen Betriebssystemebene enthält (\seeref{sec:cordova}) \cite{PhoneGap_Build_Documentation_getting-started}.
Ist der Build-Prozess abgeschlossen, kann die \gls{app} im jeweiligen Format für die verschiedenen \glspl{plattform} als Direkt-Link oder per \gls{qr} heruntergeladen werden (\seeref{fig:phonegap_build_workflow} und \ref{fig:phonegap-build_apps}).


\image{phonegap_build_workflow}
	{width=1\textwidth}
	{PhoneGap\,Build-Workflow}
		{Schematische Darstellung eines möglichen Entwicklungsworkflows mit \gls{pg-build}: Der Code wird als Web-Anwendung auf \gls{github} hochgeladen, bei \gls{pg-build} über das \gls{github}-Repository aktualisiert und für die jeweiligen \glspl{plattform} gebaut, sodass die plattformspezifischen \glspl{app} heruntergeladen und auf den Zielgeräten installiert werden können.}
	{Eigene Grafik.}

%TODO Als SVG einbinden! -> Funktioniert noch nicht.
%TODO Bildquellen (auch die *innerhalb* des Bilder angeben.)

\image{phonegap-build_apps}
	{width=1\textwidth}
	{PhoneGap\,Build-Oberfläche}
		{Oberfläche des \gls{pg-build}-Portals: Detailansicht für eine Beispiel-\gls{app}. Hier können verschiedene Einstellungen vorgenommen werden, sowie der Code aus einem Repository aktualisiert und die fertig gebaute \gls{app} per Download-Button oder \gls{qr} heruntergeladen werden.}
	{Eigener Screenshot.}

\image{screenshot_app_android}
	{width=1\textwidth}
	{Tablet-Screenshot mit installierter PhoneGap\,Build-App}
	{Die Beispiel-App (\enquote{HelloWorld}) aus \autoref{fig:phonegap-build_apps} aus \gls{pg-build} auf einem \gls{android}-Gerät installiert.}
	{Eigener Screenshot.}
